<!doctype html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="../../icons/logoTit.png">
    <link rel="stylesheet" href="../../estilo.css">
    <title>UB Social</title>
</head>
<body>
<div class="container-fluid">


    <div class="row">
        <div class="col-sm-12">
            <nav class="navbar rounded-bottom fixed-top navbar-expand-lg navbar-light bg-light shadow">
                <div class="container-fluid">
                    <a class="navbar-brand" href="../../index.html"><img src="../../icons/logo.png" class="d-inline-block align-text-top" width="11pt"> UB Social</a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                    <div class="collapse navbar-collapse" id="navbarNav">
                        <ul class="navbar-nav">
                            <li class="nav-item"><a class="nav-link" href="../../index.html">Home</a></li>
                            <li class="nav-item"><a class="nav-link" href="../../sobre/sobre.html">Sobre</a></li>
                            <li class="nav-item"><a class="nav-link" href="../../livros/livros.html">Livros</a></li>
                        </ul>
                    </div>
                </div>
            </nav>
        </div>
    </div>

    <div class="row">
        <div class="col-sm-12 text-center" id="titulo">
            <img src="tux.png" class="img-fluid rounded" width="70px">
            <h1>Linux</h1>
            <h6><strong>Teoria e prática</strong></h6>
            <a href="../../index.html" class="btn btn-link text-decoration-none mb-3">Voltar</a><br>
            <a href="https://youtube.com/playlist?list=PLnPZ9TE1Tj4DMd5YpzLGUI2y33Adh57bJ" class="btn btn-link text-decoration-none mb-3" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" width="1.3em" height="1.3em" fill="currentColor" class="bi bi-youtube text-danger" viewBox="0 0 16 16"><path d="M8.051 1.999h.089c.822.003 4.987.033 6.11.335a2.01 2.01 0 0 1 1.415 1.42c.101.38.172.883.22 1.402l.01.104.022.26.008.104c.065.914.073 1.77.074 1.957v.075c-.001.194-.01 1.108-.082 2.06l-.008.105-.009.104c-.05.572-.124 1.14-.235 1.558a2.007 2.007 0 0 1-1.415 1.42c-1.16.312-5.569.334-6.18.335h-.142c-.309 0-1.587-.006-2.927-.052l-.17-.006-.087-.004-.171-.007-.171-.007c-1.11-.049-2.167-.128-2.654-.26a2.007 2.007 0 0 1-1.415-1.419c-.111-.417-.185-.986-.235-1.558L.09 9.82l-.008-.104A31.4 31.4 0 0 1 0 7.68v-.123c.002-.215.01-.958.064-1.778l.007-.103.003-.052.008-.104.022-.26.01-.104c.048-.519.119-1.023.22-1.402a2.007 2.007 0 0 1 1.415-1.42c.487-.13 1.544-.21 2.654-.26l.17-.007.172-.006.086-.003.171-.007A99.788 99.788 0 0 1 7.858 2h.193zM6.4 5.209v4.818l4.157-2.408L6.4 5.209z"/></svg> Conteúdo disponível</a>
        </div>
    </div>

    <div class="row">
        <div class="col-sm-12">

            <div class="card mb-4">
                <h4 class="card-header">Fundamento</h4>
                <div class="card-body">
                    <p>Criado em 1991 por Linus Torvalds, Linux não é um SO completo. É um kernel livre baseado em Unix (Ken Thompson e Dennis Ritchie), Minix, desenvolvido em C, considerado, inicialmente, um emulador de terminal para uso em Unix. Sua 1ª distribuição comercial foi a Yggdrasil Linux/GNU/X, lançada em 1992, no formato Live CD. Através de Richard Stallman, Linus conhece o projeto GNU, onde, futuramente, licencia o kernel Linux (GNU Linux). O mascote do Linux é o Tux (Torvalds' Unix ou Tuxedo). Atualmente, 90% dos servidores web são Linux, correspondendo 99% dos supercomputadores no mundo. Linux está presente na maior parte de nossa rotina, como em dispositivos embarcados (smart TVs, Android, MacOS, video games, eletrodomésticos, multimídias automotivas, caixas eletrônicos), órgãos governamentais (forças armadas, departamentos governamentais), aplicações críticas (trens bala, CERN, sistemas de tráfego aéreo, reatores nucleares, foguetes de sondagem, artilharias de guerra), entre outros. Isso ocorre porque o Linux é Free (livre), onde não há restrição legal para manuseamento do código, permitindo, dessa forma, personalização profunda, de acordo com a necessidade. Além disso, o kernel possui enorme comunidade de contribuidores, ocasionando frequentes atualizações de integridade e otimização. Seu código fonte está disponível em <a href="https://www.kernel.org" class="text-decoration-none" target="_blank">kernel.org</a>. Principais órgãos certificadores são LPI (Linux Professional Institute), Red Hat e The Linux Foundation. Esse resumo prepara você para concluir a certificação LPI Linux Essentials, a certificação básica do LPI. Tais certificações são reconhecidas mundialmente. Software livre (free software) possui código aberto (open source) e segue as diretrizes da GPL. Nem todo software open source (código aberto) é free software, nem mesmo gratuito. Customização, suporte, treinamento e serviços terceiros sob free software podem ser cobradas. Manifesto GNU (GNU not Unix) foi atrelado a FSF (Free Software Foundation), criados por Stallman para armazenar a GPL (GNU General Public License), que possui 4 liberdades:</p>
                    <ol start="0">
                        <li><b>Executar</b> o software para qualquer propósito ou finalidade;</li>
                        <li><b>Estudar</b> o funcionamento interno do software, podendo fazer alterações e adaptações conforme necessidade;</li>
                        <li><b>Modificar</b> e melhorar o software, para que a comunidade possa beneficiar-se das mesmas;</li>
                        <li><b>Distribuir</b> o software, contanto que a distribuição seja com as mesmas liberdades que o software recebido, como não fechar o código.</li>
                    </ol>
                    
                    <h5>Tipos de kernel Linux:</h5>
                    <ul>
                        <li><b>Generic (Stable)</b>: Padrão de SOs Linux;</li>
                        <li><b>LTS (Longterm)</b>: Maior suporte e estabilidade;</li>
                        <li><b>Zen</b>: Open Source, fork do Generic, objetivo de otimização;</li>
                        <li><b>Liquorix</b>: Similar ao Zen, objetivo de otimização para games e mídia;</li>
                        <li><b>Hardened</b>: Open Source, objetivo de segurança e robustez, menos performance;</li>
                        <li><b>XanMod</b>: Objetivo de performance.</li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Distros</h4>
                <div class="card-body">
                    <p>Uma distribuição (distro) Linux é um SO com kernel Linux. Atualmente, há cerca de 600 distros, nem todas gratuitas. As distros base (from scratch) são Slackware, Debian, Red Hat Enterprise Linux (RHEL), Gentoo, SUSE e Arch. Com isso, criou-se uma árvore de distros geradas a partir de suas progenitoras (<a href="https://commons.wikimedia.org/wiki/File:Linux_Distribution_Timeline_27_02_21.svg" class="text-decoration-none" target="_blank">timeline distros Linux</a>). Como exemplo, o Ubuntu é baseado no Debian, o Mint é baseado no Ubuntu. O Fedora e o CentOS são versões free do RHEL. O <a href="https://distrowatch.com" class="text-decoration-none" target="_blank">distrowatch</a> possui todas notícias sobre distros Linux. A versão não modificada do kernel Linux é chamada de 'Vanilla'. A distro mais antiga em atividade é o Slackware.</p>
                    <ul>
                        <li>Distros <b>versionadas</b> (lançamentos versionados);
                            <ul>
                                <li>LTS (long term support): Possui atualizações menos frequentes e pacotes mais estáveis;</li>
                                <li>testing: Versão não LTS, possui as mais recentes atualizações publicadas;</li>
                                <li>unstable: Possui as atualizações mais recentes e que ainda não foram publicadas (beta).</li>
                            </ul>
                        </li>
                        <li>Distros <b>rolling release</b> (lançamentos contínuos, atualizações constantes, ausência de versionamento).</li>
                    </ul>
                    
                    <h5>GUI e CLI:</h5>
                    <p>Toda distro é <b>CLI</b> (command-line interface), onde há ausência de interface gráfica, sendo somente modo texto. Servidores geralmente utilizam somente CLI. Distros com adesão de GUI (graphical user interface) possuem interface gráfica, sendo essa renderizada através de <b>desktop environment</b> (DE). Desktop environment engloba a interface gráfica do gerenciador de janelas, além de seus respectivos softwares. Os DEs são diferentes no que diz respeito a uso de recursos de hardware no dispositivo, customização e aparência. Entre os principais gerenciadores de janelas, tem-se:</p>
                    <ul>
                        <li>Gnome (GNU network object model environment): Principal DE Linux, possui widget toolkit GTK e servidores gráficos Xorg e Wayland. Caracteriza-se por ser mais responsivo e completo. Portanto, consome mais recursos de hardware do dispositivo;</li>
                        <li>KDE (K desktop environment): Utiliza widget toolkit Qt. Caracteriza-se por ser extremamente customizável e consome poucos recursos de hardware do dispositivo;</li>
                        <li>XFCE (XForms common environment): Caracteriza-se por ser mais estável e consumir menos recursos de hardware do dispositivo. Utiliza servidor gráfico Xorg;</li>
                        <li>MATE (MATE advanced traditional environment): Nome advindo da 'erva-mate', caracteriza-se por ser leve e customizável;</li>
                        <li>LXDE (Lightweight X11 desktop environment): Caracteriza-se por consumir pouquíssimos recursos de hardware do dispositivo;</li>
                        <li>LXQt (LXDE + Qt): Utiliza widget toolkit Qt, caracteriza-se por consumir pouquíssimos recursos de hardware do dispositivo;</li>
                        <li>Cinnamon: Caracteriza-se por ser extremamente similar ao Windows. Consome poucos recursos de hardware do dispositivo;</li>
                        <li>Fluxbox: Caracteriza-se por consumir pouquíssimos recursos de hardware do dispositivo;</li>
                        <li>Deepin DE (desktop environment): Caracteriza-se por ser extremamente similar ao MacOS;</li>
                        <li>Pantheon: Caracteriza-se por ser extremamente similar ao MacOS;</li>
                        <li>Unity;</li>
                        <li>WindowMaker;</li>
                        <li>AwesomeWM;</li>
                        <li>Entre outros.</li>
                    </ul>
                    <p>Em muitas situações, pode-se optar por qual DE instalar na distro. Como, por exemplo, no Debian, optar entre Debian Gnome, Debian KDE, Debian XFCE, etc. Distros com DEs como XFCE, LXQt, MATE e Fluxbox são ideais para hardware obsoleto. Distros com DEs como XFCE, KDE e Cinnamon possuem mais similaridade com Windows. Distros com DEs como Pantheon e Deepin DE possuem mais similaridade com MacOS.</p>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Instalação</h4>
                <div class="card-body">
                    <p>Existem diversas formas para utilizar distros Linux. Pode-se instalá-lo diretamente na máquina (<b>bare metal</b>), via pendrive bootável (live boot), unicamente ou ao lado de outro SO já presente no dispositivo (dual boot, multi boot). Primeiramente, precisa-se baixar o arquivo .iso da distro, para posteriormente formatar o pendrive com a .iso selecionada (pendrive bootável), através de algum software específico, como balenaEtcher. Após formatação concluída, o computador precisa ser reiniciado e sua BIOS acessada (F12), para selecionar opção de boot do pendrive. Os principais instaladores de distros Linux são Anaconda (Sabayon), DI (Debian-Installer), Drakx Installer (Mandriva/Mageia), Sysinstaller, Ubiquity (Ubuntu16), Calamares (Red Hat), YaST (SUSE), etc. Outro meio para utilizar distro Linux é através de <b>VM</b> (virtual machine) com o arquivo .iso da distro. Outra alternativa é através de <b>containers</b>. Via Windows, pode-se utilizar distro Linux via <b>WSL</b> (Windows Subsystem for Linux). Por fim, pode-se utilizar distro Linux online, via plataforma <b>cloud</b>, como Amazon, Azure, GCP, etc. Distros <b>modo incógnito</b> são live USB que são executadas na memória RAM do dispositivo, com processamento e armazenamento volátil, ou seja, removido após desligamento do dispositivo.</p>

                    <h5>Tipos de instalação (iso):</h5>
                    <ul>
                        <li><b>USB</b>: Geralmente associada à pendrive bootável, para instalação/teste no dispositivo;</li>
                        <li><b>Live</b>: Geralmente associada à Live USB, para utilizar a distro sem necessidade de instalação. Leve;</li>
                        <li><b>CD</b>: Geralmente mais leve, possui menos recursos, geralmente necessita de internet para instalação de demais programas, ou descartando, dependendo do tamanho do CD. Geralmente instalação mais direta que USB;</li>
                        <li><b>DVD</b>: Geralmente mais pesada, possui todos os recursos para instalação, geralmente descartando internet. Mais pesada que o comum;</li>
                        <li><b>NetInstall</b>: Geralmente associada, ou à USB ou à pequeno CD, para instalação totalmente dependente de internet. Extremamente leve;</li>
                        <li><b>non-free</b>: Imagem completa, contendo, inclusive, toda gama de conectores de hardware de todos fabricantes. Geralmente a mais pesada;</li>
                        <li><b>Netboot</b>: Forma de instalação. Geralmente associada à instalação direta, via rede TFTP, DHCP/BOOTP/RARP, utilizando PXE e TFTP;</li>
                        <li><b>Torrent</b>, <b>Container</b>, <b>ARM</b>, <b>Cloud</b>, <b>VM</b>, <b>Mobile</b>, <b>Build Scripts</b>: Outras formas de instalação, sendo build scripts os arquivos de códigos.</li>
                    </ul>

                    <h5>Particionamento de disco:</h5>
                    <p>Particionamento de disco com 500GB disponíveis para armazenamento e 4GB de RAM, para instalação de Ubuntu 20. Formatação do tipo GPT (GUID Partition Table), será da seguinte forma:</p>
                    <ul>
                        <li><b>Boot</b>: Partição para boot da distro, tipo primária FAT32, com label <i>/boot/efi</i>, com média de 800MB;</li>
                        <li><b>Swap</b>: Partição de memória virtual, tipo primária linux-swap, sem label, com média de metade do tamanho da RAM ou mais (aqui no caso 2GB);</li>
                        <li><b>Root</b>: Partição raíz, onde ficará o sistema, tipo primária journaling EXT4 (ou BTRFS), com label <i>/</i>, preenchendo com o restante do espaço livre.
                            <ul>
                                <li><span class="text-muted">Opcional</span> (Partição <b>home</b> separada): Partição onde ficarão os arquivos dos usuários (documentos, imagens, vídeos, etc), do tipo primária journaling EXT4, com label <i>/home</i>, preenchendo com o espaço livre restante (Neste caso, 40% do espaço livre restante será de home, e os demais 60% será de root);</li>
                                <li><span class="text-muted">Opcional</span> (<b>criptografa</b>): Pode-se criptografar a participação root com o LUKS (Linux Unified Key Setup-on-disk-format).</li>
                            </ul>
                        </li>
                    </ul>
                    <p>Toda distro Linux possui codecs (compatibilizadores de formatos de mídia), pode-se configurar snapshots via gerenciador de backups Timeshift, realizar tarefas agendadas de Cron/Crontab, UFW (Ubuntu firewall) e GUFW (Graphical), gestão de configurações Tweaks, entre outras funcionalidades. Há possibilidade de executar softwares incompatíveis com Linux via softwares interpretadores, como <b>Wine</b> (Wine is not emulator) e <b>PlayOnLinux</b>, através da implementação livre da API do Windows e engenharia reversa.</p>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Estrutura</h4>
                <div class="card-body">
                    <p>No Linux não existem programas, drivers e extensões: Tudo é considerado arquivo. Dispensando conceito de 'pasta', a estrutura de diretórios de arquivos no Linux possui padrão POSIX, baseada em FHS (File system Hierarchy Standard). Até mesmo os componentes de hardware são controlados por arquivos em realtime. Nos caminhos de diretórios, tem-se o <i>caminho absoluto</i> (originado a partir do diretório root até o diretório atual, exemplo: <span class="text-muted">/home/ubsocial/arquivo</span>. Comando 'pwd' mostra caminho absoluto - print world directory) e caminho relativo (originado a partir de diretório qualquer até o diretório atual, exemplo <span class="text-muted">ubsocial/arquivo</span>).</p>
                    <ul>
                        <li>Diretório root: <b>/</b> <span class="text-muted">(cd /)</span></li>
                        <li>Diretório home: <b>~</b> <span class="text-muted">(cd ~)</span> o mesmo que '/home/usuarioAtual'</li>
                        <li>Diretório atual: <b>.</b> <span class="text-muted">(cd .)</span></li>
                        <li>Diretório pai: <b>..</b> <span class="text-muted">(cd ..)</span></li>
                        <li>Diretório anterior: <b>-</b> <span class="text-muted">(cd -)</span></li>
                    </ul>
                    <p>Todo arquivo oculto inicia com ponto (<b>.</b>) antes do nome. Diretórios possuem barra (<b>/</b>) no final do nome. Diretórios com <b>@</b> no final do nome são links simbólicos, ou seja, atalhos para o diretório real.</p>

                    <h5>Estrutura de diretórios:</h5>
                    <ul>
                        <li><b>/</b> (root): Diretório originário de todos os demais, onde encontram-se os diretórios abaixo;</li>
                        <li><b>/bin</b>: Possui todos os binários (binaries), comandos/alias do Shell. Link simbólico para '/usr/bin'. Exemplo, alias 'ls' refere-se a '/bin/ls', ou seja, '/usr/bin/ls';</li>
                        <li><b>/boot</b>: Arquivos para inicialização (boot) do Linux, como gerenciador GRUB e imagem do kernel;</li>
                        <li><b>/cdrom</b>: Diretório legado (não pertence a FHS), para montagem temporária de imagem de CD-DVD. Local atual para tal é '/media';</li>
                        <li><b>/dev</b>: Arquivos de dispositivos (devices), como periféricos, como hd (sda, vda), ssd e usb (sda, sdb), cdrom, disquete floppy (fd) e tty;</li>
                        <li><b>/etc</b>: Abreviação de 'etcetera' ou 'edit do/to config'. Arquivos de configuração do sistema, como scripts de inicialização, módulos de programas, tabela de sistema de arquivos (fstab - file system table), configurações de services e usuários;</li>
                        <li><b>/home</b>: Arquivos dos usuários do sistema. Cada usuário é representado por diretório com seu nome, contendo seus respectivos arquivos dentro (área de trabalho, documentos, imagens, etc);</li>
                        <li><b>/lib, /lib32, /libx32, /lib64</b>: Bibliotecas (libraries) compartilhadas e módulos do kernel. Libraries são scripts que podem ser utilizados por outros arquivos dependentes para seu funcionamento. Links simbólicos para '/usr/lib', '/usr/lib32', 'usr/libx32' e '/usr/lib64';</li>
                        <li><b>/lost+found</b>: Diretório geralmente oculto (/.lost+found) de 'achados e perdidos', usado para reparos no sistema;</li>
                        <li><b>/media</b>: Ponto de montagem para mídias removíveis (media), como cdrom, floppy, webcam, usb, hd e ssd externos;</li>
                        <li><b>/mnt</b>: Ponto de montagem temporária (mount) de sistema de arquivos, como outros SOs e cdrom (similar ao '/media');</li>
                        <li><b>/opt</b>: Abreviação de 'optional', utilizado por arquivos proprietários, não licenciados pela GNU;</li>
                        <li><b>/proc</b>: Processos (process) do Linux e todas informações do hardware (cpu, memória e partições). Diretório virtual (gravado em RAM, volátil, todos arquivos nele são apagados no desligamento do dispositivo);</li>
                        <li><b>/root</b>: Arquivos do usuário administrador (root), para administração de interface de rede, usuários e grupos, prioridades, entre outros;</li>
                        <li><b>/run</b>: Diretório virtual de arquivos temporários sensíveis e informações de services em execução (run, runtime);</li>
                        <li><b>/sbin</b>: Link simbólico para '/usr/sbin', possui os super binários (super binaries ou system binaries), comandos/alias do administrador do Linux (root), utilizados para inicialização, reparação e restauração do sistema, e informações sensíveis de rede;</li>
                        <li><b>/srv</b>: Serviços (service) do Linux, como rede, acessíveis externamente. Geralmente utilizado para instalação de servidores web ('/srv/www') e ftp ('/srv/ftp');</li>
                        <li><b>/sys</b>: Diretório virtual de mapeamento de chamadas diretas ao kernel (system), similar ao '/proc', sendo mais organizado e categorizado;</li>
                        <li><b>/tmp</b>: Diretório virtual de arquivos temporátios (temp, temporary);</li>
                        <li><b>/usr</b>: Recursos do Linux (user, unix system resources), como libraries e binaries, scripts do kernel ('/src'), além de arquivos não essenciais ao sistema, que seguem padrão GNU;</li>
                        <li><b>/var</b>: Arquivos de informações e tamanho variável (variable), como cache, logs e impressão ('/spool').</li>
                    </ul>

                    <h5>Camadas distro Linux:</h5>
                    <ol>
                        <li><b>Hardware</b>: Componentes físicos do dispositivo;</li>
                        <li><b>Kernel Linux</b>: Núcleo mediador entre hardware e camadas superiores;</li>
                        <li><b>Sistema operacional</b>: Camada que auxilia e hospeda todos arquivos das camadas superiores;</li>
                        <li><b>Teletypes</b> (tty1, tty2, tty3, tty4, tty5, tty6...63): Terminais virtuais, responsáveis por interpretar os comandos (binaries);</li>
                        <li><b>DM</b> (display manager): Gerenciamento de login e ambiente gráfico;</li>
                        <li><b>Desktop environment</b>: Ambiente GUI de hospedagem dos programas.</li>
                    </ol>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">File systems e devices</h4>
                <div class="card-body">
                    <h5>File systems:</h5>
                    <p>File system tem objetivo de gerenciar os bytes de dados no dispositivo.</p>
                    <ul>
                        <u>Microsoft</u>:
                        <li><b>FAT32</b> (File allocation table): Utilizado em Windows, não suporta journaling;</li>
                        <li><b>exFAT</b> (Extensible FAT): Alternativa ao FAT, melhor compatibilidade entre diferentes file systems. Possui pouquíssimos recursos e suporta arquivos de tamanhos diversos. Ideal para pendrives e HDs externos que acessam diferentes file systems;</li>
                        <li><b>NTFS</b> (New technology file system): Evolução do FAT32, suporte de volumes maiores, possui checksums em journaling e snapshots em volume shadow copy. Compatível com leitura de dados em outros file systems, mas com compatibilidade de escrita instável;</li>
                        <u>Linux</u>:
                        <li><b>ext4</b> (Extended file system): Mais popular em dispositivos Linux "domésticos", possui checksums em journaling;</li>
                        <li><b>ZFS</b> (Zettabyte file system): Gerencia vários volumes (pool), checksums próprios e confiáveis, snapshots e copy on write (COW). O openZFS é a versão free do ZFS. Utilizado em servidores;</li>
                        <li><b>BTRFS</b> (B-tree file system): Simimlar ao ZFS, com otimizações e aberto. Ideal para servidores.</li>
                    </ul>

                    <h5>Devices:</h5>
                    <p>Linux possui 3 formatos de gerenciamento de dados: <b>stdin</b> 0 (standard input, entrada de dados, como via teclado), <b>stdout</b> 1 (standard output, saída de dados, como via display tela) e <b>stderr</b> 2 (standard error, feedback de erro, como via display tela). Pode-se alterar o padrão, como redirecionar stderr para arquivo ('<span class="text-muted">ls erro > arquivo</span>'). O diretório '/dev' armazena arquivos dos dispositivos periféricos, com exceção de placas de rede, que são carregadas via módulo do kernel. Em '/dev' há '/devfs' ou '/udev'. '/dev' carrega todos os módulos ("drivers") do Linux, incluindo os não presentes no hardware host. '/udev' carrega somente módulos encontrados no hardware host, além da configuração automatizada codeplug e hotplug. Seu arquivo de configurações é '/etc/udev/udev.conf' e seus arquivos de regras (rules) estão em '/etc/udev/rules.d/'. Os comando <i>udevmonitor</i> e <i>udevadm monitor</i> permitem modificar eventos armazenados no sistema lógico sysfs, onde ficam as identificações dos dispositivos.</p>
                    
                    <h5>Tipos de devices:</h5>
                    <ul>
                        <li><b>Caractere</b> (c): Orientados à comunicação e fluxo de informações de modo serial, ou seja, caractere a caractere. Utilizados por comunicações entre portas seriais ou paralelas, como modens, e tty's (comunicação com o kernel);</li>
                        <li><b>Bloco</b> (block): Orientados ao armazenamento de informações temporárias de mídia. Geralmente utilizado para representar partições, hd's (sda ou vda) e pendrives;</li>
                        <li><b>FIFO</b> (first in, first out): Processamento de dados em formato de fila, viabilizando comunicação entre dois processos independentes;</li>
                        <li><b>Socket</b>: Voltados à criação de ponto de comunicação.</li>
                    </ul>

                    <h5>Diretórios dos devices:</h5>
                    <ul>
                        <li><b>/dev/fd0</b> e <b>/dev/fd1</b>: Respectivamente, 1ª e 2ª unidade de disquete (floppy disk);</li>
                        <li><b>/dev/hda</b> e <b>/dev/hdb</b>: Dispositivos HD IDE master (hda) e slave (hdb);
                            <ul>
                                <li><b>/dev/hda0</b>: 1ª partição do dispositivo IDE master;</li>
                                <li><b>/dev/hda1</b>: 2ª partição do dispositivo IDE master, e assim por diante;</li>
                            </ul>
                        </li>
                        <li><b>/dev/sda</b> e <b>/dev/sdb</b>: Respectivamente, 1º e 2º dispositivo SSD SATA;
                            <ul>
                                <li><b>/dev/sda1</b>: 1ª partição do dispositivo SATA;</li>
                                <li><b>/dev/sda2</b>: 2ª partição do dispositivo SATA, e assim por diante;</li>
                                <li><b>/dev/sdd</b>: Cartões que seguem padrão SATA/SCSI;</li>
                            </ul>
                        </li>
                        <li><b>/dev/cdrom</b>: Dispositivos cdrom.</li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Usuários</h4>
                <div class="card-body">
                    <p>O usuário comum (<b>$</b>) é o padrão para utilização do Linux, possui restrições de gerenciamento sensíveis ao sistema. O administrador <b>sudo</b> (super user do) possui permissão total de gerenciamento do sistema. O <b>usuário de sistema</b> é fictício, criado durante a instalação de algum script, para execução de tarefas específicas ao mesmo, não possuindo capacidade de login no sistema. O <b>root</b> (<b>#</b>, id 0), é o super user (<span class="text-muted">su</span>) possui permissão total de gerenciamento do sistema. O root é o único usuário com permissão de gerenciamento fora de seu diretório home.</p>

                    <h5>Arquivos de usuário:</h5>
                    <p>Arquivo '/etc/passwd' possui informações dos usuários, separadas por ':'. Constituem, respectivamente, login do usuário, senha ('x', determinando que a senha está em '/etc/shadow', ou '*', determinando que o login está desabilitado, ou linha em branco, determinando ausência de senha), UID (user identification), GID (group identification), GComs (dados de comentários do usuário, separados por vírgula), localização home do usuário e shell do usuário. Arquivo '/etc/shadow' possui informações do usuário. Constituem, respectivamente, login do usuário, senha criptografada, data da modificação de senha (nº de dias), nº de dias para Linux permitir nova modificação de senha, nº de dias que o usuário pode manter mesma senha, nº de dias para expirar senha, nº de dias após expiração de senha, nº de dias até expiração de senha e campo reservado para futura informação.</p>
<small><pre><code>
<u><b>Informações de usuários</b></u>:
<b>Username</b>: Nome do usuário
<b>Password Status</b>: P(senha utilizável), L(senha bloqueada), NP(não há senha)
<b>Change Date</b>: Data de última modificação de senha
<b>Minimum</b>: Nº mínimo de dias que deve passar para permitir alteração de senha
<b>Maximum</b>: Nª de dias restantes para senha expirar
<b>Warn</b>: Nº de dias, antes da expiração de senha, para notificar usuário
<b>Inactive</b>: Nº de dias, após expiração de senha, que usuário permanece ativo

<u><b>Comandos de usuários</b></u>:
<b>w</b>: Ver detalhes de usuários conectados
<b>whoami</b>: Ver usuário atual
<b>quota</b>: Informações do usuário na sessão
<b>getent passwd</b>: Abrir passwd
<b>pwconv</b>: Criar arquivo '/etc/shadow' a partir de '/etc/passwd' <span class="text-muted">(pwunconv faz operação inversa)</span>
<b>sudo + comando</b>: Comando em modo administrador
<b>sudo su</b>: Entrar no usuário root
<b>su - nomeUsuario</b>: Sair do usuário root, para usuário comum
<b>Alterar senha de usuário</b>: passwd [parâmetros] [utilizador] <spam class="text-muted">(passwd -S sysadmin)</spam>
</small></pre></code>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Rede</h4>
                <div class="card-body">
                    <h5>Componentes de rede:</h5>
                    <ul>
                        <li><b>eth</b> (eth0, eth1, eth2...): Ethernet, placa de rede cabeada do dispositivo;</li>
                        <li><b>wlo</b> (wlo0, wlo1, wlo2...), <b>wlan</b> (wlan0, wlan1, wlan2...): Wlo é wireless network interface (NIC). Wireless-LAN (Local Area Network), plca de wifi do dispositivo;</li>
                        <li><b>ra</b> (ra0, ra1, ra2...): Placa de rede com chipset Ralink;</li>
                        <li><b>lo</b>: Loopback, interface de rede virtual do dispositivo para conexões TCP/IP.</li>
                    </ul>
                    <p>Entre os comandos de rede, tem-se <b>route</b> (<span class="text-muted">route -n</span>) para visualizar e manipular tabela de roteamento IP (inet) e gateway. O <b>ifconfig</b> e <b>iwconfig</b> para informações dos componentes de rede do dispositivo, <b>ip a</b>, <b>ip r</b> e <b>nmcli</b> são similares a ambos. <b>ip addr show</b> mostra IP do dispositivo. <b>netstat</b> ou <b>ss</b> mostra todas conexões de entrada e saída de rede, tabelas de roteamento e estatísticas do protocolo de rede. '<i>netstat -atunp</i>' mostra com detalhes de PID, TCP e UDP. <b>ping</b> mostra tempo de envio/recebimento de resposta em rede (Ex: '<span class="text-muted">ping -c 4 192.168.1.2</span>' (Ping para esse IPV4 limitado em 4 iterações). Ex2: '<span class="text-muted">ping uol.com.br</span>' (Ping no site do uol)). <b>host</b> (<i>host -opcao idHost</i>) localiza informações de rede como, por exemplo, IPV4 (opção -4) ou IPV6 (opção -6) de determinado host. As portas de rede encontram-se em '/etc/services'. Entre os firewalls Linux, tem-se <b>iptables</b>, juntamente com <b>UFW</b> (Ubuntu firewall), que possui o GUFW como serviço GUI para gerenciamento. MacAddress é o id da placa física, geralmente identificado como link/ether, HWaddr ou HW, seguindo padrão 'xx:xx:xx:xx:xx:xx' (Ex: <span class="text-muted">5c:cd:5b:74:ae:32</span>). O MacAddress da placa wifi do dispositivo geralmente encontra-se em wlan, identificado como 'HWaddr' ou 'ether'. Também pode ser encontrado com <b>inxi -Nn</b> na opção state 'up'.</p>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Terminais</h4>
                <div class="card-body">
                    <p>Emulador de terminal é o programa que emula um terminal, no Linux representado pelo shell. Terminais virtuais (<b>tty</b>, teletypes) suportam o ambiente do sistema. Para acessar a tty utiliza-se 'ctrl+alt+FnumTty' (Ex: '<span class="text-muted">ctrl+alt+F2</span>' acessará tty2), para alternar a tty utiliza-se 'alt+FnumTty'. Algumas tty's carregam GUI (geralmente tty1 e tty2), outras somente CLI (geralmente tty3 a 6).</p>

                    <h5>Sessões:</h5>
                    <p>Linux funciona sob sessão(ões) ativa(s). O login criará 1 sessão, composta por dados gerados do mesmo. Todo o log no sistema pertencerá a sessão ativa. Um mesmo usuário pode criar várias sessões ao mesmo tempo (cada shell executado e não fechado criará nova sessão). Toda vez que usuário comum executar '<span class="text-muted">sudo su</span>', criará nova sessão com root, e poderá encerrá-la com '<span class="text-muted">exit</span>', '<span class="text-muted">ctrl+d</span>' ou '<span class="text-muted">logout</span>' para retomar a sessão com usuário comum.</p>

                    <h5>Shell:</h5>
                    <p>Camada de acesso básico ao Linux, utilizada para execução de binários e super binários. Para executar shell, basta informar seu nome ou diretório (Ex: '<span class="text-muted">/usr/bin/sh</span>'). Comandos para encerrá-lo são os mesmos de sessão acima. Entre os tipos de shell, tem-se:</p>
                    <ul>
                        <li>sh (Bourne shell)</li>
                        <li>bash (Bourne again shell, evolução do sh)</li>
                        <li>csh (C shell)</li>
                        <li>tcsh (Turbo C shell, evolução do csh)</li>
                        <li>ksh (Korn shell)</li>
                        <li>zsh (Z shell)</li>
                    </ul>

                    <h5>Variáveis:</h5>
                    <p>Espaços de memória que armazenam valores, com função de fornecer dados ao sistema. Comando <b>echo</b> faz chamada de conteúdo no shell em stdout (Ex: '<span class="text-muted">echo "ola"</span>' mostrará "ola" na tela). Para listar todas variáveis, tem-se 'set' (locais), 'env' (globais) e 'printenv'.</p>
                    <ul>
                        <li><b>Variáveis locais</b>: Disponíveis somente para shell atual, são voláteis, possuindo visibilidade restrita ao ambiente onde foi definida. Sintaxe: <span class="text-danger">nome=valor</span>;</li>
                        <li><b>Variáveis globais</b> (de ambiente, environment): Não possuem restrição de ambiente, disponíveis a todo sistema. Sintaxe: <span class="text-danger">export NOME=valor</span>.</li>
                    </ul>
                    <ul>
                        <u>Variáveis globais</u>:
                        <li>HOME: Identifica o diretório do usuário;</li>
                        <li>HOSTTYPE: Identifica a plataforma do dispositivo;</li>
                        <li>HISTSIZE: Armazena limite de comando armazenados em histórico (histfile, padrão é 1000);</li>
                        <li>HISTFILE: Identifica local onde histórico de comandos é armazenado;</li>
                        <li>HISTFILESIZE: Armazena limite de linhas que o histórico (histfile) pode possuir (padrão é 2000);</li>
                        <li>SHELL: Identifica o shell atual;</li>
                        <li>TERM: Identifica o terminal atual;</li>
                        <li>USER: Identifica o usuário atual;</li>
                        <li>PATH: Identifica caminhos que determinam onde os diretórios devem pesquisar (separados por ':');</li>
                        <li>PS1: Representa as informações exibidas no prompt (linha do shell para comando, como '<span class="text-muted">usuario@nomeMaquina:~$</span>');</li>
                        <li>LOGNAME: Identifica nome do usuário logado atual;</li>
                        <li>OSTYPE: Identifica SO atual.</li>
                    </ul>
<small><pre><code>
<b>Exemplo</b>:
nome="ubsocial"
echo $nome <span class="text-muted">(toda vez que nome for chamada, representará seu valor: <i>ubsocial</i>)</span>
unset nome <span class="text-muted">(descarta variável)</span>
echo $HOME <span class="text-muted">(exibirá valor de HOME)</span>
</small></pre></code>

                    <h5>Alias:</h5>
                    <p>Apelido/atalho atrelado a determinada rotina. Comando 'alias' listará todos aliases do sistema.</p>
<small><pre><code>
<b>Exemplo</b>:
alias j="ls -l"
j <span class="text-muted">(ao digitar 'j' será executado seu valor: Comando 'ls -l')</span>
unalias j <span class="text-muted">(descarta alias)</span>
</code></pre></small>

                    <h5>Arquivos de variáveis:</h5>
                    <ol>
                        <u>Escopo global</u>:
                        <li><i>/etc/profile</i>: Armazena comandos e variáveis para usuários do sistema;</li>
                        <li><i>/etc/environment</i>: Usado para definir variáveis globais;</li>
                        <u>Escopo local</u> (/home):
                        <li><i>.bashrc</i></li>
                        <li><i>.profile</i> ou <i>._profile</i></li>
                        <li><i>._login</i> e <i>._logout</i></li>
                        Comando 'source' reseta o arquivo (Ex: '<span class="text-muted">source /etc/profile</span>').
                    </ol>

                    <h5>Arquivos de exibição de mensagens:</h5>
                    <ul>
                        Responsáveis por armazenar mensagens padrão stderr.
                        <li><i>/etc/issue</i>: Mensagens antes do login do sistema;</li>
                        <li><i>/etc/motd</i>: Mensagens após login do sistema;</li>
                        <li><i>/etc/issue.net</i>: Mensagens via rede, logins remotos;</li>
                        <li><i>~/.bash_history</i>: Histórico dos comandos.</li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Shell</h4>
                <div class="card-body">
                    <p>Comando interpretado pelo shell possui composição:</p>
                    <ol>
                        <li><b>comando</b>: Arquivo binário em '/usr/bin';</li>
                        <li><b>parâmetro(s)</b>: Opcional, altera comportamento do comando. Também chamado de 'flag' e 'opção'. Representado por 1 hífen seguido de letra (forma simplificada), ou 2 hífens seguidos de palava (forma extensa). Na forma simplificada, pode-se conter vários parâmetros aninhados, onde tem-se 1 hífe seguido das letras dos respectivos parâmetros;</li>
                        <li><b>argumento(s)</b>: Opcional, especifica alvo do comando. Representado por palavra(s) ou expressão(ões).</li>
                        <i class="text-muted">Resumidamente, parâmetro modifica execução do comando para determinado argumento.</i>
                    </ol>
                    <p>Sintaxe 1: <span class="text-danger">comando [-p] [argumento]</span><br>Sintaxe 2: <span class="text-danger">comando [--parametro] [argumento]</span></p>
                    
                    <u>Exemplos</u>:
                    <p><span class="text-muted">ls -s /home</span><br><span class="text-muted">ls -s -a /home</span><br><span class="text-muted">ls -sa /home</span><br><span class="text-muted">ls --size /home</span><br><span class="text-muted">ls --size --all /home</span></p>

                    <h5>Atalhos shell</h5>
                    <ul>
                        <li><b>tab</b>: Autocompletar comando;</li>
                        <li><b>seta up</b>: Comando anterior;</li>
                        <li><b>seta down</b>: Mostrar comando sucessor ao anterior;</li>
                        <li><b>^c</b>: Quer dizer <i>ctrl+c</i>;</li>
                        <li><b>M-c</b>: Quer dizer <i>alt+c</i>;</li>
                        <li><b>ctrl+shift+c</b>: Copiar;</li>
                        <li><b>ctrl+shift+v</b>: Colar;</li>
                        <li><b>ctrl+a</b>: Mover cursor ao começo da linha;</li>
                        <li><b>ctrl+e</b>: Mover cursor ao final da linha;</li>
                        <li><b>ctrl+u</b>: Recortar tudo à esquerda do cursor;</li>
                        <li><b>ctrl+k</b>: Recortar tudo à direita do cursor;</li>
                        <li><b>ctrl+y</b>: Colar conteúdo recortado;</li>
                        <li><b>alt+b</b>: Voltar 1 palavra;</li>
                        <li><b>ctrl+w</b>: Deletar 1 palavra;</li>
                        <li><b>ctrl+p</b>: Comando anterior;</li>
                        <li><b>ctrl+n</b>: Próximo comando;</li>
                        <li><b>ctrl+c</b>: Abrir nova linha a partir do cursor (cancelar operação em andamento);</li>
                        <li><b>ctrl+d</b>: Sair;</li>
                        <li><b>alt+f</b>: Mover 1 palavra;</li>
                        <li><b>alt+d</b>: Deletar 1 palavra;</li>
                        <li><b>ctrl+r</b>: Iniciar/Próxima pesquisa;</li>
                        <li><b>ctrl+g</b>: Cancelar pesquisa;</li>
                        <li><b>ctrl+x</b> ou <b>+e</b>: Editar;</li>
                        <li><b>ctrl+l</b>: Limpar shell (move cursor para baixo até ocultar conteúdo anterior);</li>
                        <li><b>ctrl+-</b>: Desfazer.</li>
                    </ul>

                    <h5>Comandos gerais:</h5>
<small><pre><code>
<b>Ver shell padrão</b>: echo $SHELL (ou 'echo $0')
<b>Data e hora do sistema</b>: date
<b>Fechar o bash</b>: exit
<b>Limpar bash</b>: clear
<b>Ajuda no bash</b>: help
<b>Comentário no Bash</b>: #comentario (Comentários não afetam execuções no shell)
<b>Concatenar comandos</b> (; ou &&): ls ; echo "a" (ou ls && echo "a")

<b>Histórico de comandos</b>: history
<b>Histórico dos 10 últimos comandos</b>: history 10 (ou fc -l 10)
<b>Histórico dos comandos 2 ao 6</b>: fc -l 2 6
<b>Histórico dos comandos na última hora</b>: fc -l h
<b>Executar 34º comando do histórico</b>: !34

<b>Ver informações de hardware</b>: lshw
<b>Ver informações da distro</b> (necessário instalar): neofetch
<b>Ver versão da distro</b>: lsb_release -a (ou cat /etc/*-release)
<b>Ver versão do kernel</b>: uname -r
<b>Ver detalhes do kernel</b>: uname -a
<b>Ver informações de memória cache em tempo real</b>: sudo slabtop (ctrl+c para sair)
<b>Ver arquitetura da máquina</b>: arch
<b>Ver particionamento do disco</b>: lsblk
<b>Ver espaços das partições</b>: df (-i para mostrar inodes, buracos de memória no hardware de cada partição)
<b>Ver informações sobre uso do disco</b>: du (du -sh *)
<b>Ver mensagens do sistema</b>: sudo dmesg
<b>Ver quantidade de memória livre</b>: free
<b>Verificar e reparar sistema de arquivos</b>: fsck
<b>Ver módulos kernel carregados em memória</b>: lsmod
<b>Ver arquivos abertos</b>: lsof
<b>Ver dispositivos pci</b>: lspci
<b>Ver dispositivos scsi</b>: lsscsi
<b>Ver dispositivos usb</b>: lsusb
<b>Subshell (comando dentro de comando)</b>: ls $(which docker)

<b>Desligar</b>: shutdown now (ou poweroff, ou init 0, ou shutdown 0)
<b>Logout</b>: logout
<b>Reiniciar</b>: reboot (ou shutdown -r)
</code></pre></small>

                    <h5>Create:</h5>
<small><pre><code>
<b>Criar diretório</b> (make directory): mkdir diretorio1 diretorio2 diretorio3
<b>Criar diretório com subdiretório</b>: mkdir -p diretorio1/diretorio2/diretorio\ 3/ ('\' não interpreta próximo caractere como comando ("diretorio 3"). '-p' não sobrescreve, caso diretório já exista)
<b>Criar arquivo</b>: touch nomearquivo (ou 'touch arquivo\ de\ teste' para criar "arquivo de teste")
</code></pre></small>

                    <h5>Remove:</h5>
<small><pre><code>
<b>Remover arquivo</b>: rm arquivo
<b>Remover diretório vazio</b>: rmdir diretorio
<b>Remover diretório não vazio</b> (recursive): rm -r diretorio (-f para remoção forçada)
<b>Remover sob confirmação</b> (interactive): rm -i arquivo
</code></pre></small>

                    <h5>List:</h5>
<small><pre><code>
<b>Listar conteúdo do diretório atual</b>: ls
<b>Listar conteúdo em diretório específico</b>: ls nomeDiretorio
<b>Listar diretório e subdiretórios</b>: ls -R
<b>Listagem com detalhes</b>: ls -l
<b>Listagem com informações aprimoradas de armazenamento</b>: ls -l -h
<b>Listagem incluindo arquivos ocultos</b>: ls -a
<b>Listagem com informações de armazenamento, arquivos ocultos e subdiretórios</b>: ls -Rlah
<b>Ver metadados de arquivo</b>: stat nomeArquivo
<b>Ver formato de arquivo</b>: file nomeArquivo
<b>Ver conteúdo de arquivo</b>: cat nomeArquivo ('tac' mostra inversamente)
<b>Ver conteúdo de arquivo, com paginação</b>: less /etc/services (Less: 'n' pula pra próxima página, '/termo' procura por termo específico)
<b>Inserir conteúdo de arquivo em outro arquivo</b>: cat arquivo &gt; arquivoGravacao
<b>Inserir conteúdo de arquivo no final de outro arquivo</b>: cat arquivo &gt;&gt; arquivoGravacao

<b>Conteúdo do 'ls -l'</b>:
<span class="text-danger">[tipoArquivo] [permissões(proprietário/grupo/outros)] [contagem linksFisicos] [proprietárioDoUsuario] [proprietárioDoGrupo] [tamanhoArquivoBouKB] [dthrRegistro] [nomeArquivo.extensao]</span>
Exemplo (arquivo): <span class="text-muted">-rw-r--r-- 1 root root 18047 Dec 20 2021 alternatives.log</span>
Exemplo (diretório): <span class="text-muted">drwxr-x--- 2 root adm 4096 Dec 20 2021 apache2</span>

<b>d</b>: Diretório
<b>-</b>: Arquivo regular (Indica que é arquivo, não sendo diretório)
<b>l</b>: Link simbólico (Aponta para outro arquivo)
<b>s</b>: Arquivo é um socket (Comunicação entre processos)
<b>p</b>: Arquivo é um fifo, named pipe (Comunicação entre processos. Fifo- FistIn FirstOut, muito usado para filas de elementos em lista de espera)
<b>b</b>: Arquivo é dispositivo de bloco (Comunicação com hardware, com buffer: região temporária de memória para escrita/leitura)
<b>c</b>: Arquivo é dispositivo de caractere (Comunicação com hardware, sem buffer)
<b>u</b>: O mesmo que <i>c</i>
</code></pre></small>

                    <h5>Print:</h5>
<small><pre><code>
<b>Impressão simples</b>: lp arquivo.txt
<b>Impressão avançada</b>: lp -d nomeImpressora -n 2 -P 1,3 Documents/arquivo (2 cópias, páginas 1 e 3)
<b>Detalhes da impressora</b>: lpstat -p -d
<b>Ver fila de impressão</b>: lpq
</code></pre></small>

                    <h5>Change directory:</h5>
<small><pre><code>
<b>Entrar em outro diretório</b>: cd nomeDiretorio (Exemplo: 'cd /home/usuario/Documents')
<b>Voltar 1 diretório (diretório pai)</b>: cd ..
<b>Voltar 2 diretórios</b>: cd ../../ (e assim por diante)
<b>Entrar no diretório do usuário</b>: cd (ou cd ~)
<b>Enrtar no diretório root</b>: cd /
</code></pre></small>

                    <h5>Copy e move:</h5>
<small><pre><code>
<b>Copiar e colar arquivo</b>: cp arquivo diretorioDestino
<b>Copiar e colar recursivamente</b>: cp -r dirOrigem dirDestino (-p mantém metadados)
<b>Mover</b>: mv arquivo diretorioDestino (o mesmo vale para diretórios)
<b>Renomear</b>: mv arquivoAtual arquivoNovo (o mesmo vale para diretórios)
<b>Comparar arquivos</b>: diff arquivo1 arquivo2 ('-r' recursivo, '-i' ignora CamelCase, '-a' compara qualquer tipo de arquivo)

<b>Copiar e colar</b> (bit a bit): dd if=/dev/arquivo1 of=/tmp/arquivo2 bs=1M count=50
if: arquivo de entrada, a ser lido
of: arquivo de saída, a ser gravado
bs: tamanho do bloco (Kilobyte, Megabyte, Gigabyte, Terabyte, etc.)
count: contagem de blocos a serem lidos da entrada
</code></pre></small>

                    <h5>Regular expressions:</h5>
                    <p>Também conhecidos por globbing (file globbing), são caracteres regex utilizados em conjunto.</p>
<small><pre><code>
<u><b>Metacaracteres</b> (representação)</u>:
<b>.</b> Qualquer caractere único
<b>*</b> Conjunto de caracteres
<b>?</b> Apenas 1 caractere
<b>[ ]</b> Intervalo de caracteres
<b>[a-z][0-9]</b> Caracteres de 'a' até 'z', caracteres de '0' até '9'
<b>[a,z][0,9]</b> Caracteres 'a' e 'z', caracteres '0' e '9'
<b>[a-z,1,0]</b> Caracteres de 'a' até 'z' ou '1' ou '0'
<b>[^ ]</b> Faixa de caracteres ausentes
<b>{ }</b> Padrões de caracteres
<b>x{ab,01}</b> Caracteres 'xab' ou 'x01'
<b>x{a-c,f}</b> Caracteres 'xa', 'xb', 'xc' ou 'xf'
<b>^</b> Se o 1º caractere do padrão, o padrão deve estar no início da linha
<b>$</b> Se o último caractere do padrão, o padrão deve estar no final da linha
<b>+</b> 1 ou mais do padrão anterior
<b>|</b> Alternativa ao <b>-</b> um 'ou' lógico
<b>( )</b> Agrupamento
<b>!</b> Excluir caractere da operação
<b>\b</b> Borda de uma palavra
<b>\n</b> Recuperar n agrupamento (n é um nº)
<b>\</b> Acessar caracteres especiais e metacaracteres

<u><b>Classificação</b></u>:
<b>Marcação</b> (âncoras): ^ $ \b
<b>Quantificadores</b>: . ? * + {n[,m]} [...] [^...]
<b>Agrupamento</b>: () \n
<b>Outros</b>: \

<u><b>Exemplos</b></u>:
<b>Criar arquivos</b>: touch arq{1-3}.txt (gerará 'arq1.txt', 'arq2.txt' e 'arq3.txt')
<b>Listar tudo que começa com 'x'</b>: ls /etc/x*
<b>Listar tudo que tem 'x' no meio</b>: ls /etc/*x*
<b>Listar tudo que termina com '.conf'</b>: ls /etc/*.conf
<b>Listar tudo que termina com, ou 'tab' ou 'swd'</b>: ls /etc/*{tab,swd}
<b>Listar tudo que tem 2º caractere 'a', 3º 's', e depois qualquer coisa</b>: ls /etc/?as*
<b>Listar tudo que tem 'a' na 4ª posição, depois qualquer coisa</b>: ls /etc/???a*
<b>Listar tudo que começa com 'f', seguido de caractere na faixa entre 'a' e 'i', depois qualquer coisa</b>: ls /etc/f[a-i]*
<b>Listar tudo que começa com 'f', seguido de caractere 'a' ou 'c', depois qualquer coisa</b>: ls /etc/f[a,c]*
<b>Listar tudo que começa com 'f', seguido de caractere entre 'a' até c, ou 'e', depois qualquer coisa</b>: ls /etc/f[a-c,e]*
<b>Listar tudo que tenha no meio caracteres de 'a' até 'c', depois qualquer coisa</b>: ls /etc/*[a-c]*
<b>Listar tudo que, por 2º, listar ou 'am' ou 'ul', depois qualquer coisa</b>: ls /etc/?{am,ul}*
<b>Listar tudo que, por 2º, listar sequência do 'a' até 'm' ou do 'u' até 'l', depois qualquer coisa</b>: ls /etc/?[am,ul]*
<b>Procurar em 'arquivo.txt' termos que terminam com 'teste'</b>: grep '$teste' arquivo.txt
</code></pre></small>

                    <h5>Permissões:</h5>
                    <p>No Linux, nenhum arquivo externo tem permissão de execução nativamente. Precisa-se aplicá-la com comandos <b>chown</b> e <b>chmod</b>:</p>
                    <p>Sintaxe: <span class="text-danger">chmod [&lt;conjunto&gt;&lt;ação&gt;&lt;permissões&gt;] arquivo</span></p>
                    Ordenamento:
                    <ol>
                        <span class="text-muted">-rw-r--r-- 1 sysadmin sysadmin 647 Dec 20 2017 hello.sh</span>
                        <li>(rw-) <b>Proprietário</b>, no caso o primeiro sysadmin;</li>
                        <li>(r--) <b>Grupo</b>, no caso o segundo sysadmin;</li>
                        <li>(r--) <b>Outros</b>, no caso outros usuários não proprietários do arquivo.</li>
                    </ol>
                    Conjunto:
                    <ul>
                        <li>(<b>u</b>) Usuário proprietário do arquivo;</li>
                        <li>(<b>g</b>) Grupo proprietário do arquivo;</li>
                        <li>(<b>o</b>) Outros (qualquer usuário que não seja o proprietário do usuário ou membro do proprietário do grupo);</li>
                        <li>(<b>a</b>) Todos (refere-se ao usuário, grupo e outros)</li>
                    </ul>
                    Ação:
                    <ul>
                        <li>(<b>+</b>) Adicionar permissão;</li>
                        <li>(<b>=</b>) Especificar permissão;</li>
                        <li>(<b>-</b>) Remover permissão.</li>
                    </ul>
                    Classificação:
                    <ul>
                        <li>Simbólico: Alterar conjunto de permissões de cada vez;
                            <ul>
                                <li>(<b>r</b>): Read (leitura);</li>
                                <li>(<b>w</b>): Write (escrita);</li>
                                <li>(<b>x</b>): Execution (execução).</li>
                            </ul>
                        </li>
                        <li>Octal: Alterar todos conjuntos de permissões (usuário, grupo e outros).
                            <ul>
                                <li>(<b>0</b>) Nenhuma permissão (-rwx);</li>
                                <li>(<b>1</b>) Execução (x);</li>
                                <li>(<b>2</b>) Escrita (w);</li>
                                <li>(<b>3</b>) Escrita e execução (wx);</li>
                                <li>(<b>4</b>) Leitura (r);</li>
                                <li>(<b>5</b>) Leitura e execução (rx);</li>
                                <li>(<b>6</b>) Leitura e escrita (rw);</li>
                                <li>(<b>7</b>) Leitura, escrita e execução (rwx);</li>
                                <li>(<b>-R</b>) Recursiva, afeta subdiretórios também (chmod -R 777 /home).</li>
                            </ul>
                        </li>
                    </ul>
<small><pre><code>
<u>Exemplos</u>:
chmod 764 arquivo (proprietário(7) com leitura/escrita/execução, grupo(6) com leitura/escrita, outros(4) com somente leitura)
chmod 40 arquivo (proprietário não foi modificada, grupo(4) somente leitura, outros(0) nenhuma)
</code></pre></small>

                    <h5>Lançador:</h5>
                    <p>Atalho de binário no desktop environment, em arquivo '.desktop'. Lançadores globais (disponíveis para todos usuários) ficam em '/usr/share/applications', lançadores locais (disponíveis somente para usuário da sessão) ficam em '~/.local/share/applications'.</p>
<small><pre><code>
<b>Conteúdo de arquivo do lançador</b>:
[Desktop Entry]
Type=Application
Version=1.0
Name=Nome do binário
Comment=Descrição do binário
Icon=Diretório do ícone do binário
Exec=Diretório do executável do binário
Terminal=Abrir shell (true ou false)
StartupNotify=Notificação quando executado (true ou false)
Categories=Categoria do binário
</code></pre></small>
                    Categorias:
                    <ul>
                        <li>Configurações: Settings;</li>
                        <li>Desenvolvimento: Development; Documentation;</li>
                        <li>Educação: Education;</li>
                        <li>Ciência: Science;</li>
                        <li>Escritório: Office;</li>
                        <li>Gráficos: Graphics</li>
                        <li>Rede: Network;</li>
                        <li>Jogos: Game;</li>
                        <li>Multimídia: AudioVideo;Audio;Video;AudioVideoEditing;</li>
                        <li>Sistema: System;</li>
                        <li>Utilitários: Utility.</li>
                    </ul>

                    <h5>Processos:</h5>
                    <p>No Linux, o gerenciamento de processos segue padrão POSIX. Processo é um binário que, quando executado, consome recursos do dispositivo. Possui ciclo de vida (stat), time (tempo usado pelo processador no processo), CMD (binário que iniciou o processo), recursos e usuário proprietário. Todo processo é identificado pelo <b>PID</b> (process identification) e, em alguns casos, <b>PPID</b> (parent process identification), com prioridade de execução (nice), do -20 (máxima) ao 19 (mínima) e 0 (padrão). O root possui permissão para alterar prioridades. Processos criados pelo root têm prioridade 0. Processos criados por usuário comum têm prioridade 10 (baixa). Processos em realtime (normalmente internos do kernel) possuem prioridade 1 a 99. Processos convencionais possuem têm prioridade 100 (maior) até 139 (menor), sendo 120 (padrão) e rt (realtime). A prioridade padrão (PRI/PR), diferente da nice (NI), é definida automaticamente no escalonamento definido pelo kernel. Processos em execução possuem seus diretórios em '/proc', nomeados por PID. Processos podem ser inicializados pelos gerenciadores <i>systemctl</i> e <i>systemd</i>. Comando 'top' mostra lista de processos. A gestão do processo ocorre via sinais de kill (comando 'kill -l' mostra todos sinais de kill).</p>
                    Componentes do processo:
                    <ul>
                        <li>Estado (stat);
                            <ul>
                                <li>(<b>R</b>) running (em execução, consome recursos);</li>
                                <li>(<b>T</b>) stopped (parado, não consome recursos);</li>
                                <li>(<b>S</b> ou <b>D</b>) sleeping (hibernando ou com dificuldades de retornar à execução, não consome recursos);</li>
                                <li>(<b>Z</b>) zoombie (travado, não executa funções, consome recursos);</li>
                                <li>(<b>X</b>) finish (finalizado, não consome recursos).</li>
                            </ul>
                        </li>
                        <li>Recursos: Recursos de hardware ou sistema (libraries);
                            <ul>
                                <li>(<b>VSZ</b>) virutal size (tamanho virtual);</li>
                                <li>(<b>RSS</b>) resident set size (memória utilizada);</li>
                                <li>(<b>SHR</b>) memória compartilhada;</li>
                                <li>(<b>tty ?</b>) processo daemon (execução independente de tty);</li>
                                <li>(stat <b>l</b> ou <b>L</b>) processo com recurso bloqueado na memória.</li>
                            </ul>
                        </li>
                        <li>Proprietário: Usuário que gerou o processo, com permissão para modificá-lo. Usuário comum é proprietário somente de seus processos. root é proprietário de todos processos;</li>
                        <li>Prioridade: Quantidade disponibilizada de recursos fornecidos;
                            <ul>
                                <li>(stat <b>&lt;</b> ou <b>N</b>) prioridade menor que normal;</li>
                                <li>(stat <b>&gt;</b>) prioridade maior que normal;</li>
                                <li>(stat <b>s</b>) líder da sessão;</li>
                                <li>(stat <b>+</b>) executando em 1º plano;</li>
                                <li>(<b>NI</b>) nice/renice, valor de prioridade definido na criação/alteração do processo;</li>
                            </ul>
                        </li>
                        <li>PID, PPID: Identificadores do processo.</li>
                    </ul>
<small><pre><code>
<b>Ver processos</b>: 'ps -ef' ou 'ps -aux' ou 'ps -r' (-r para somente running)
<b>Ver processos, filtro</b>: 'ps -ef | grep init' (todos processos 'init') ou 'ps --pid numPID' ou '--ppid numPPID' (filtro por id)
<b>Ver processos, forma personalizada</b>: ps ax -o user,pid,ppid,%cpu,%mem,stat,start,command | head -3
<b>Listar processos e processos filhos</b>: 'ps faux' ou 'ps -e f'
<b>Ver PID do processo</b>: pidof nomeProcesso (pidof init)
<b>Mostrar dados de processo</b>: top numPID
<b>Processos de usuário específico</b>: top -u usuario
<b>Processos de arquivo específico</b>: fuser nomeArquivo
<b>Processos em árvore</b>: pstree
<b>Encerrar processo</b>: kill -15 numPID (função sigterm, similar a 'kill numPID')
<b>Parar processo</b>: kill -19 numPID (sigstop)
<b>Matar processo</b>: kill -9 numPID (sigkill)
<b>Continuar processo stopped</b>: kill -18 numPID (sigcont)
<b>Criar processo com prioridade</b>: nice -n -10 nomeProcesso (prioridade -10)
<b>Matar todos processos de software</b>: 'killall nomeSoftware' ou 'pkill nomeSoftware'
<b>Alterar prioridade</b>: 'renice numPrioridade -p numPID' ou 'nice -n numPrioridade nomeProcesso'
<b>Ignorar sinais ao processo</b>: Torná-lo daemon, para mantê-lo em execução mesmo com shell fechado, 'nohup ping 8.8.8.8 &' (sighup. As saídas do nohup ficam em 'nohup.out')
<b>Parar processo para background</b>: ctrl+z (sigquit, similar a 'kill -3')
<b>Ver processos parados em background</b>: jobs
<b>Retmoar processo parado em background, para foreground</b>: fg idJob
<b>Alterar estado do processo em background (como stopped para running)</b>: bg idJob
<b>Enviar processo running para background</b>: nomeProcesso &
</code></pre></small>

                    <h5>Shell script:</h5>
                    <p>Script de execução em shell Linux, em linguagem shell, arquivos com terminação '.sh'. Realizam manipulação em rotinas shell Linux. Prévia execução, precisa-se dar permissão de execução ao mesmo. Executa-se com o comando './arquivo.sh'. Exemplo de shell script para criação de 3 diretórios, arquivo 'teste.sh' (criará 'dir1', 'dir2' e 'dir3'):</p>
<small><pre><code>
#!/bin/bash
x=1
while [ $x -le 3 ];
do
    mkdir dir$x
    echo "dir$x criado"
    ((x=$x+1))
done
echo "Concluído!"
</code></pre></small>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Localização</h4>
                <div class="card-body">
                    <p>Encontrar arquivos no sistema. Comando 'locate' realiza pesquisa simples, utilizando base de dados (updatedb) ao invés de recursividade nas buscas (Ex: '<span class="text-muted">locate howto</span>'). Comando 'find' utiliza recursividade nas buscas.<br>Sintaxe: <span class="text-danger">find [diretório] [opção/expressão]</span></p>
<small><pre><code>
<u><b>Exemplos de buscas</b></u>:
<b>Arquivos com 'teste' no diretório atual</b>: find teste
<b>Arquivos com final '.conf' no diretório '/etc'</b>: find /etc -name *.conf
<b>Limitar recursividade em diretórios</b>: find /etc -maxdepth 1 -name *.conf (apenas 1 diretório, ou seja, o atual)
<b>Arquivos acessados minutos atrás</b>: find / -amin -5 (últimos 5min)
<b>Arquivos acessados dias atrás</b>: find / -atime 10 (acessados 10 dias atrás)
<b>Arquivos por id do usuário</b>: find / -uid 1000 (arquivos do usuário 1000)
<b>Arquivos por nome do usuário</b>: find / -user root (arquivos do root)
<b>Arquivos por permissão</b>: find / -perm 644 (arquivos de permissão 644)
<b>Arquivos por tamanho</b>: find / -size +50M (arquivos com mais de 50 megabytes)
<b>Arquivos por tipo (bloco, caractere, diretório...)</b>: find /dev -type b (arquivos de bloco)
<b>Arquivos regulares vazios</b>: find / -type f -empty
<b>Arquivos executando nos últimos minutos</b>: find / -cmin -60 (últimos 60min)
<b>Diretórios modificados nos últimos dias</b>: find / -mtime 50 (últimos 50 dias)
<b>Diretórios modificados entre datas</b>: find / -mtyme +50 -mtyme -100 (entre últimos 50 e 100 dias)
</small></pre></code>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Ajuda</h4>
                <div class="card-body">
                    <ul>
                        <li><b>how-to</b> (cookbook): Documentos, disponíveis em '/usr/share/doc', focados em necessidade específica, como montar um firewall. Possuem formatos HTML, Markdown, entre outros (Ex: how-to do iptables estão em '/usr/share/doc/iptables');</li>
                        <li><b>man page</b>: Manuais de ajuda geral, via comando 'man'. Há o termo com o nº do manual indicado ('gzip(1)' é o man1 do gzip). Sintaxe: <span class="text-danger">man [sessão] [comando]</span>. Sessão pode alterar manual do comando (Ex: 'man passwd' é man1 do comando passwd, 'man 5 passwd' é man5 do arquivo de configuração passwd). Comando 'catman' atualiza a base de dados dos manuais. Manuais estão em '/usr/share/man'. Comandos <b>yelp</b> e <b>xman</b> são ferramentas GUI para tal;
                            <ul>
                                <li>man 1: Binários e executáveis;</li>
                                <li>man 2: Rotinas do sistema Linux e linguagem C;</li>
                                <li>man 3: Rotinas e libraries da linguagem C;</li>
                                <li>man 4: Arquivos especiais (dispositivos em '/dev');</li>
                                <li>man 5: Arquivos de configurações e convenções;</li>
                                <li>man 6: Games;</li>
                                <li>man 7: Diversos (macros textuais, por exemplo, regex);</li>
                                <li>man 8: Super binários;</li>
                                <li>man 9: Rotinas internas do kernel.</li>
                            </ul>
                        </li>
                        <li><b>help</b>: Providencia manuais de ajuda específicos para binários internos (Ex: 'help type' ajuda para comando type). Binários externos são executados com '--help' (Ex: 'cd --help');</li>
                        <li><b>info</b>: Info pages são similares às man pages, possuindo mais recursos de navegação. Sintaxe: <span class="text-danger">info [termo]</span> (Ex: 'info vim');</li>
                        <li><b>whatis</b>: Busca por referências idênticas (Ex: 'whatis passwd'). Comando '<span class="text-muted">man -f termo</span>' é similar;</li>
                        <li><b>which</b>: Mostra localização do binário (Ex: 'which ls');</li>
                        <li><b>apropos</b>: Busca por referências similares (Ex: 'apropos email address'). Comando '<span class="text-muted">man -k termo</span>' é similar;
                            <ul>
                                <li>(<b>-d</b>): Exibir mensagens de depuração;</li>
                                <li>(<b>-v</b>): Verbose, exibir detalhes do andamento da pesquisa;</li>
                                <li>(<b>-e</b> ou <b>--exact</b>): Busca por referência idêntica;</li>
                                <li>(<b>-w</b> ou <b>--wildcard</b>): Busca com expressões regulares;</li>
                                <li>(<b>-a</b> ou <b>--and</b>): Busca concatenada de 2 ou mais termos que se correspondam;</li>
                                <li>(<b>-l</b> ou <b>--long</b>): Resultado de saída sem quebra de linha;</li>
                                <li>(<b>-C</b>): Dispensar padrão (/ manpath), trocando-o por arquivo de configuração personalizado;</li>
                                <li>(<b>-L</b>): Definir diretório da busca;</li>
                                <li>(<b>-m</b> ou <b>--systems</b>): Usar man pages externas;</li>
                                <li>(<b>-M</b> ou <b>--manpath</b>): Definir caminho de busca das man pages para PATH ao invés do $MANPATH padrão;</li>
                                <li>(<b>-s</b> ou <b>--section</b> ou <b>--sections</b>): Busca em sessões específica (separadas por '<b>:</b>');</li>
                                <li>(<b>-r</b> ou <b>--regex</b>): Interpretar termo pesquisado como regex.</li>
                            </ul>
                        </li>
                        <li><b>whereis</b>: Localizar binário e manual do comando (Ex: 'whereis ls' mostrará '/usr/bin/ls' e '/usr/share/man/man1/ls.1.gz').
                            <ul>
                                <li>(<b>-b</b>): Buscar somente localização do binário;</li>
                                <li>(<b>-m</b>): Somente man pages;</li>
                                <li>(<b>-s</b>): Somente fontes;</li>
                                <li>(<b>-u</b>): Buscar termos incomuns, como arquivos de origem ou binários;</li>
                                <li>(<b>-B</b>): Alterar/limitar locais de pesquisa por binários;</li>
                                <li>(<b>-M</b>): Alterar/limitar locais de pesquisa por man pages;</li>
                                <li>(<b>-S</b>): Alterar/limitar locais de pesquisa por fontes;</li>
                                <li>(<b>-f</b>): Termina última lista de diretórios e sinaliza início dos nomes dos arquivos (deve ser usado com opções -B , -M ou -S).</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Nano editor</h4>
                <div class="card-body">
                    <p>Conteúdo aqui</p>
                </div>
            </div>






            <div class="card"><!--PEGAR AQUI-->
                <h4 class="card-header">23. Nano editor</h4>
                <div class="card-body">
                    <p>Editor CLI de texto simples padrão do Debian, baseado no Joe. Para alterar o editor de textos padrão, basta informar no comando <i>update-alternatives --config editor</i>. É carregado automaticamente no modo de edição. Para utilizar o editor basta digitar o comando nano, podendo juntamente com o nome do arquivo que deseja criar/editar. Para abrir arquivo somente leitura, basta informar <i>nano -v arquivo</i>. Na legenda <b>^</b> é <i>Ctrl</i> e <b>M</b> é <i>alt</i>. Além dos atalhos típicos, o nano possui outros atalhos:</p>
<small><pre><code>
<b>Ctrl+g</b>: Ajuda
<b>Ctrl+k</b>: Recorta a linha
<b>Ctrl+u</b>: Cola linha copiada
<b>Ctrl+_</b>: Vai para linha informada
<b>Ctrl+y</b>: Sobe 1 página
<b>Ctrl+v</b>: Desce 1 página
<b>Alt+/</b>: Vai para última linha
<b>Alt+\</b>: Vai para 1ª linha
<b>Ctrl+a</b>: Move cursor para início da linha
<b>Ctrl+e</b>: Move cursor para fim da linha
<b>Ctrl+c</b>: Apresenta informações sobre a posição do cursor (<i>Ctrl+c</i> em procedimento cancela o mesmo)
<b>Ctrl+j</b>: Texto justificado
<b>Ctrl+t</b>: Aciona corretor ortográfico (Se o comando <i>spell</i> estiver instalado)
<b>Ctrl+w</b>: Pesquisar (<i>Alt+w</i> segue a próxima ocorrência)
<b>Ctrl+w, texto, depois Ctrl+r, novoTexto</b>: Substituir texto (<i>y</i> seleciona texto, <i>a</i> substitui todas ocorrências)
<b>Alt+a</b>: Ativa/desativa selecionar texto (<i>Setas</i> fazem a seleção quando ativado)
<b>Alt+6</b>: Copia seleção
<b>Ctrl+o</b>: Salva arquivo (Pode salvar uma cópia do mesmo em outro local, com outro nome também, 'Salvar Como')
<b>Ctrl+x</b>: Sair do editor
<b>Alt+u</b>: Desfaz última alteração (Undo)
<b>Alt+e</b>: Refaz última alteração, se desfeita (Redo)
O nano possibilita a abertura de diversos arquivos ao mesmo tempo.
<b>Alt+,</b>: Move para arquivo à esquerda (Ou <i>Alt+&lt;</i>)
<b>Alt+.</b>: Move para arquivo à direita (Ou <i>Alt+&gt;</i>)
</small></pre></code>
                </div>
            </div>
            <br>





            <!-- O QUE FALTA:
                - nano
                - vim
                - compactação e empacotamento
                - pacotes
            -->

            <p class="text-center bg-danger text-light my-5 py-2"><b>FIM</b></p>








            <div class="card">
                <h4 class="card-header">24. Vim editor</h4>
                <div class="card-body">
                    <img src="mao_vi.png" class="img-fluid rounded" width="50px" >
                    <p>O principal editor de texto CLI Linux é o <b>Vi</b>, antigo <i>Ex editor</i>, porém existem outros, como <b>nano</b>, <b>emacs</b>, Joe, Pico, Mcedit, ed, entre outros. O <b>Vim</b> (Vi Improved) é a evolução do Vi, sendo o <b>gVim</b>, também conhecido como <i>vimtutor</i>, a evolução do Vim, onde há presença de GUI. Há também o <b>Neovim</b>, a evolução do Vim modo CLI. Para criar/editar arquivos no Vi, basta seguir o comando 'vi nomearquivo'. O editor abrirá no modo visual. Existem vários modos de operação, onde as teclas funcionam de diferentes maneiras, sendo o <b>Ex Mode</b> o modo inicial, ao abrir o arquivo (Também considerado como modo de Visualização ou modo de Comandos). Para sair dos modos, basta usar a tecla 'Esc'. Na maioria das distribuições Linux, tem-se um alias para o Vim, como vi. Então, quando o comando vi é executado, abrirá na verdade o Vim. O Vim possui seu arquivo de configuração em <i>/etc/vim/vimrc</i>. Para executar o Vim, abrindo ou criando um arquivo, basta digitar o comando <i>vim nomearquivo</i>. A sintaxe é: <i>vim [opções] [arquivo]</i>. Ouve-se a frase de que um usuário estava usando o Vim há anos, não porque gostava, mas porque não sabia como sair do editor. Usuários de Vi têm sinal de mão específico acima.</p>
                    <h4>Ex Mode</h4>
                    <p>O antigo Ex editor permitia ao usuário somente trabalhar de 1 linha por vez, sendo o novo Vi o antigo 'modo visual' do Ex, onde o usuário visualizava todas as linhas do arquivo em questão. A evolução incorporou o modo Ex ao Vi. Neste modo, considerado modo de Comandos, é realizada a manipulação do arquivo de forma geral, onde, logicamente, não é possível editar conteúdo do arquivo. Para os comandos abaixo, o <b>!</b> realizará o comando forçadamente, descartando warnings e consequências, como por exemplo <i>:q!</i> sairá forçadamente do arquivo, não salvando-o e não informando mensagem para tal. Abaixo, seguem comandos do Ex Mode:</p>
                    <ul>
                        <li>Lista de comandos Vim: <a href="vimComandos.png" class="text-decoration-none" target="_blank">Acesse</a></li>
                    </ul>
<small><pre><code>
<b>:i</b> - Entrar no modo Inserção
<b>:w</b> - Salvar o arquivo atual no sistema de arquivos
<b>:w nome_arquivo</b> - Salvar uma cópia do arquivo atual como nome_arquivo
<b>:w!</b> - Forçar salvar arquivo atual
<b>:1</b> - Vá para a linha 1 ou qualquer nº fornecido
<b>:e nome_arquivo</b> - Abrir nome_arquivo
<b>:q</b> - Sair se nenhuma alteração for feita no arquivo (Se houver, avisará para salvar)
<b>:q!</b> - Sair forçadamente, sem salvar as alterações no arquivo
<b>:wq</b> - Sair e salvar arquivo
<b>:u</b> - Desfazer última ação
<b>Ctrl+r</b> - Repetir/Refazer comando
<b>:X</b> - Criptografa o arquivo
<b>:syntax on</b> - Ativar syntax highlighting (Para ativar, descomentar linha no arquivo de configuração, removendo as aspas da mesma)
<b>:set nu</b> - Ativar linhas numeradas (<i>:set nu!</i> para desativar)
</small></pre></code>            
                    <h5>Movimentações</h5>
                    <p>O Vim possibilita, além das teclas abaixo, movimentações por meio das setas direcionáveis.</p>
<small><pre><code>
<b>gg</b> - Ir para início do arquivo
<b>G</b> - Ir para final do arquivo
<b>36G</b> - Ir para a 36ª linha
<b>M</b> - Ir para linha do meio da tela
<b>h</b> - Voltar 1 caractere
<b>l</b> - Avançar 1 caractere
<b>H</b> - Ir para a 1ª linha exibida na tela
<b>L</b> - Ir para a última linha exibida na tela
<b>j</b> - Abaixo 1 linha
<b>J</b> - Juntar linha atual com linha seguinte
<b>k</b> - Acima 1 linha
<b>w</b> - 1 palavra para a frente
<b>b</b> - 1 palavra atrás
<b>^</b> - Início da linha
<b>$</b> - Fim da linha
<b>Ctrl+B</b> - Voltar 1 página
<b>Ctrl+F</b> - Avançar 1 página
<b>ctrl+w+s</b> - Criar janelas verticais
<b>ctrl+w+v</b> - Criar janelas horizontais
<b>ctrl+ww</b> - Movimentar entre janelas
<b>F1</b> - Exibir tela de ajuda (<i>:q</i> Sair da tela de ajuda)
<u>Ex:</u> <b>3w</b> moverá o cursor 3 palavras para a direita
<u>Ex2:</u> <b>5h</b> moverá o cursor 5 caracteres para a esquerda
</small></pre></code>
                    <h5>Manipulações</h5>
<small><pre><code>
<b>u</b> - Desfazer modificação (Undo)
<b>s</b> - Deletar caractere atual e Colar linha
<b>S</b> - Deletar linha atual e Colar linha
<b>dgg</b> - Deletar a partir da linha visual do topo até linha do cursor
<b>yw</b> - Copiar palavra sob cursor
<b>dw</b> - Recortar palavra sob cursor
<b>Y</b> - Copiar linha
<b>y</b> - Copiar trecho selecionado
<b>D</b> - Recortar trecho selecionado
<b>uu</b> - Recortar linha
<b>V</b> - Selecionar linha(s), usando teclas de movimentações para seleção
<b>v</b> - Selecionar palavra(s), usando teclas de movimentações para seleção
<b>p</b> - Colar trecho selecionado/copiado após o cursor
<b>P</b> - Colar trecho selecionado/copiado antes do cursor
<b>r</b> - Substituir caractere atual (Replace)
<b>R</b> - Substituir conjunto de caracteres
<u>Ex:</u> <b>3y</b> copia as 3 letras em frente (cursor + 2 letras seguintes). <b>p</b> colará, após o cursor
</small></pre></code>
                    <h5>Exclusões</h5>
<small><pre><code>
<b>x</b> - Excluir caractere sob cursor
<b>dd</b> - Excluir linha atual
<b>3dd</b> - Excluir as próximas 3 linhas
<b>dw</b> - Excluir palavra atual
<b>d3w</b> - Excluir as próximas 3 palavras
<b>d4h</b> - Excluir 4 caracteres à esquerda
</small></pre></code>
                    <h5>Modificações</h5>
<small><pre><code>
<b>cc</b> - Mudar linha atual
<b>cw</b> - Mudar palavra atual
<b>c3w</b> - Mudar as próximas 3 palavras (Apaga para mudar)
<b>c5h</b> - Mudar 5 caracteres para a esquerda (Apaga para mudar)
</small></pre></code>
                    <h5>Arrancar (Yank)</h5>
                    <p>Yank coloca conteúdo no buffer sem excluí-lo (Copiar).</p>
<small><pre><code>
<b>yy</b> - Arranque a linha atual
<b>3yy</b> - Arranque as próximas 3 linhas
<b>yw</b> - Arranque as próximas 3 linhas
</small></pre></code>
                    <h5>Pesquisa</h5>
                    <p>O Vi aceita termos e expressões regulares para pesquisa. Pesquise, no Ex Mode, a partir da posição atual do cursor, usando <b>/</b> para iniciar a pesquisa, digite o termo de pesquisa e pressione 'Enter' para pesquisar. O cursor se moverá para a 1ª correspondência que for encontrada. Use 'n' para seguir para as próximas correspondências, usando 'N' para retroceder (Pesquisa <b>?</b>). No Ex mode, para substituir todas as palavras 'Caza' por 'Casa' utilize '<i>:%s/Caza/Casa/g</i>'.</p>
                    <h4>Modo de Inserção (i)</h4>
                    <p>Neste modo, o usuário poderá modificar o conteúdo interno do arquivo. Neste modo, utilize 'delete' para apagar conteúdo. Use 'esc' para sair do modo e voltar a utilizar o Ex Mode. O modo de Inserção, por padrão, faz a inserção de texto à esquerda do cursor. Caso desejar o contrário, informe a tecla <b>a</b> para inserção de texto à direita do cursor, ou seguindo as demais ações abaixo.</p>
<small><pre><code>
<b>Teclas de ações no Ex Mode:</b>
<b>a</b> - Entrar no modo de inserção logo após o cursor
<b>A</b> - Entrar no modo de inserção no final da linha
<b>i</b> - Entrar no modo de inserção logo antes do cursor
<b>I</b> - Entrar no modo de inserção no início da linha
<b>o</b> - Entrar no modo de inserção em uma linha em branco após o cursor
<b>O</b> - Entrar no modo de inserção em uma linha em branco antes do cursor
<b>Esc</b> - Sair do modo (Funciona para todos os modos)
</small></pre></code>
                </div>
            </div>
            <br>

            <div class="card">
                <h4 class="card-header">30. Compactação e Empacotamento</h4>
                <div class="card-body">
                    <p>A utilização de compactadores pode ser muito proveitosa quando utilizada em backups, pois a mesma reduz o espaço quando o conteúdo é compactado. Podem haver situações em que existem arquivos com final <i>.tar.gz</i>, o que significa que o mesmo fora empacotado com tar e compactado com gzip.</p>
                    <p><b>Empacotamento:</b><br>Quando vários arquivos são empacotados em um só arquivo. Exemplos de empacotadores são <b>tar</b> e <b>cpio</b>.</p>
                    <p><b>Compactação:</b><br>Quando um arquivo maior é compactado para se tornar menor. Exemplos de compactadores são <b>zip</b>, <b>gzip</b> e <b>bzip2</b>.</p>
                    <h4>tar</h4>
                    <p>TAR (Tape Archive) é um empacotador de arquivos, preservando as informações (metadados) dos arquivos envolvidos. Pode ser utilizado em conjunto com empacotadores. Em momentos de empacotamento, haverão mensagens de feedback informando remoção de '/', para a segurança da não substituição do diretório original pelo gerado, extraindo assim no diretório presente, não no diretório original empacotado. Sintaxe: <i>tar [opções] &lt;dispositivo/arquivo.tar&gt; &lt;arquivo1&gt; [arquivo2] …</i></p>
                    <ul>
                        <li><b>-c</b> ou <b>--create</b>: Empacotar arquivo.</li>
                        <li><b>-f</b>  ou <b>--file</b>: Indicar se o arquivo empacotado será arquivo.tar do próprio SO ou se o mesmo será externo. <u>Obrigatório informar essa flag!</u></li>
                        <li><b>-j</b> ou <b>--bzip2</b>: Indica se o pacote será compactado no momento do empacotamento, utilizando bzip2.</li>
                        <li><b>-J</b> ou <b>--xz</b>: Indica que o pacote será compactado no momento do empacotamento, utilizando o xz.</li>
                        <li><b>-v</b> ou <b>--verbose</b>: Exibe na tela todo o procedimento de empacotamento/desempacotamento.</li>
                        <li><b>-t</b> ou <b>--list</b>: Visualizar o conteúdo interno no pacote.</li>
                        <li><b>-z</b> ou <b>--gzip</b>: Indica que o pacote será compactado no momento do empacotamento, utilizando gzip.</li>
                        <li><b>-x</b> ou <b>--extract</b>: Para desempacotar arquivo empacotado tar.</li>
                    </ul>
<small><pre><code>
<b><u>Exemplos:</u></b>
<b>Empacotar:</b> tar -cf arquivoPronto.tar arquivoEmpacotar
<b>Desempacotar:</b> tar -xf arquivoPronto.tar
</small></pre></code>
                    <h4>gzip</h4>
                    <p>Compactador/descompactador de arquivos. Arquivos compactados com gzip possuem final <i>.gz</i>. Um diretório não pode ser compactado, de forma direta, pelo gzip, tendo que tornar-se, primeiramente, um arquivo empacotado, para depois ser compactado (Ex: <i>.tar.gz</i>), advinda da flag <i>-z</i> no tar. Sintaxe: <i>gzip [opções] &lt;arquivo&gt;</i></p>
                    <ul>
                        <li><b>-c</b> ou <b>--stdout</b>: Compacta arquivo.</li>
                        <li><b>-d</b> ou <b>--decompress</b>: Descompacta arquivo.gz.</li>
                        <li><b>-f</b> ou <b>--force</b>: Força compactação/descompactação de arquivo (Como para arquivo já descompactado com mesmo nome do que será).</li>
                        <li><b>-l</b> ou <b>--list</b>: Exibe informações sobre arquivo compactado.</li>
                        <li><b>-q</b> ou <b>--quiet</b>: Sair.</li>
                        <li><b>-r</b> ou <b>--recursive</b>: Compacta, recursivamente, os arquivos.</li>
                        <li><b>-t</b> ou <b>--test</b>: Testa a integridade do arquivo compactado, a fim de não corromper o mesmo.</li>
                        <li><b>-v</b> ou <b>--verbose</b>: Exibe o processo de compactação/descompactação em detalhes.</li>
                        <li><b>-&lt;nivel&gt;</b> ou <b>--fast</b> ou <b>--best</b>: Gerenciar grau de compactação. Nível (1-9), quanto menor o nível, menor a compactação (mais simples), sendo menor o tempo do processo. A mesma lógica do contrário. O fast é mesmo que nível 1, o best é mesmo que nível 9.</li>
                    </ul>
<small><pre><code>
<b><u>Exemplos:</u></b>
<b>Ver arquivo compactado <i>.gz</i>, sem descompactá-lo</b>: zcat arquivoCompactado.tar.gz (Há outros comandos, como <i>zgrep</i>, <i>zless</i>, <i>zmore</i>, pode-se utilizar também comando <i>| grep</i>)
<b>Compactar</b>: gzip nomeArquivo
<b>Compactar, redirecionando saída</b>: gzip -c arquivoGrande &gt; arquivoCompactado.gz
<b>Descompactar</b>: gzip -d arquivo.gz

<b>Juntar/Compactar, Tar e Gzip (Compact Gzip File)</b>: tar -czf arquivoCompactado.tar.gz diretorioArquivosAlvo
<b>Extrair, Tar e Gzip (Extract Verbose Gzip File)</b>: tar -xvzf arquivoCompactado.tar.gz
<b>Extrair, Tar e Bzip2 (Extract Bzip2 Verbose File)</b>: tar -xjvf arquivoCompactado.tar.bz2
</small></pre></code>
                    <h4>bzip2</h4>
                    <p>Compactador/descompactador de arquivos similar ao gzip. Os arquivos compactados possuirão final <i>.bz2</i>. As flags são as mesmas do gzip, com exceção da compressão de arquivos via tar. Sintaxe: <i>bzip2 [opções] &lt;arquivo&gt;</i></p>
<small><pre><code>
<b><u>Exemplos:</u></b>
<b>Compactar tar</b>: bzip2 pastaEmpacotada.tar (Gerará <i>pastaEmpacotada.tar.bz2</i>)
<b>Descompactar</b>: bzip2 -d pastaEmpacotada.tar.bz2
<b>Descompactar mostrando tempo (Funciona no gzip também)</b>: time bzip2 -d pastaEmpacotada.tar.bz2
<b>Ver arquivo compactado .bz2, sem descompactá-lo</b>: bzcat arquivo.bz2 (Há outros comandos, como <i>bzgrep</i>, <i>zless</i> e <i>zmore</i>)
</small></pre></code>
                    <h4>xz</h4>
                    <p>O utilitário xz também é utilizado para compactar/descompactar arquivos. Arquivos compactados com xz possuem final <i>.xz</i>. As flags são as mesmas dos utilitários acima. Sintaxe: <i>xz [opções] &lt;arquivo&gt;</i></p>
<small><pre><code>
<b><u>Exemplos:</u></b>
<b>Compactar diretório teste:</b> xz -c teste > testinho.xz
<b>Descompactar:</b> xz -d teste.xz
<b>Empacotar (tar) e compactar (xz):</b> tar -cJf ./arquivoCompactado.tar.xz diretorioAlvo/
<b>Descompactar (xz) e desempacotar (tar):</b> tar -xJf arquivoCompactado.tar.xz
</small></pre></code>
                    <h4>gunzip</h4>
                    <p>Utilizado apenas para descompactar, tendo exatamente a mesma função de <i>gzip -d</i>. Utiliza as mesmas principais flags acima. Sintaxe: <i>gunzip [opções] &lt;arquivo&gt;</i><br><u>Exemplo:</u> <i>gunzip arquivoCompactado.tar.gz</i></p>
                    <h4>bunzip2</h4>
                    <p>Utilizado apenas para descompactar arquivos, tendo exatamente a mesma função de <i>bzip2 -d</i>. Utiliza as mesmas principais flags acima. Sintaxe: <i>bunzip2 [opções] &lt;arquivo&gt;</i><br><u>Exemplo:</u> <i>bunzip2 arquivoCompactado.tar.bz2</i></p>
                    <h4>unxz</h4>
                    <p>Utilizado apenas para descompactar arquivos, tendo exatamente a mesma função de <i>xz -d</i>. Utiliza as mesmas principais flags acima. Sintaxe: <i>unxz [opções] &lt;arquivo&gt;</i><br><u>Exemplo:</u> <i>unxz arquivoCompactado.tar.xz</i></p>
                </div>
            </div>
            <br>

            <div class="card">
                <h4 class="card-header">31. Pacotes</h4>
                <div class="card-body">
                    <p>Todo Linux trabalha com repositórios de pacotes, os <b>PPAs</b> (Personal Package Archive - Exemplo adicionar PPA do Kdenlive: <i>sudo add-apt-repository ppa:kdenlive/kdenlive-stable</i>), que são atualizados em conjunto, de forma automática ou com 1 comando via terminal. Repositórios são servidores que hospedam pacotes. Determinados softwares não possuem seus repositórios inseridos por padrão nativos na Distro, portanto precisam ser acrescentados antes da instalação de seu determinado pacote. Pacotes <b>Sandbox</b> não necessitam de libraries do sistema, pois as dependências já são colocadas no momento do empacotamento, trazendo assim mais segurança para o pacote e o SO. Toda Distro possui sua tabela de repositórios, que pode ser manipulada. Repositórios locais, no Brasil, tendem a ser mais rápidos que os demais, como o da Universidade Federal do Paraná por exemplo. Entre os principais gerenciadores de pacotes, tem-se o <b>apt</b> e <b>dpkg</b> para Distros Debian, o <b>yum</b>, <b>dnf</b> e <b>rpm</b> para Distros Red Hat (Red Hat Package Manager), o <b>yast</b>, <b>Entropy</b> (<i>equo</i>) para distros Sabayon, <b>Portage</b> (emerge) para Gentoo, <b>ZYpp</b> para Distros Suse, <b>XBPS</b> (xbps) para distros Void, <b>Eopkg</b> (eopkg) para distros Solus e o <b>pacman</b> e <b>pamac</b> para Distros Arch/Manjaro. Dentro desse assunto, tem-se também o <b>launchpad</b>, plataforma colaborativa, criada pela Canonical, para desenvolvimento e instalação de Software Livre. O comando <i>aptitude</i> serve como ferramenta CLI para gerenciamento de pacotes, em alto nível. <i>aptitude search nomeprograma</i> localiza pacotes disponíveis. O comando <i>aptitude install nomeprograma</i> instala pacotes disponíveis. O comando para procurar pacotes apt é <i>sudo apt search pacotePesquisado</i>. Além disso, tem-se gerenciadores de pacotes externos, como o próprio aptitude e o <b>pip</b>, que faz o gerenciamento de pacotes Python. Externamente, tem-se programas como o <b>cURL</b>, juntamente com suas libraries (libcurl), que interface CLI para transferência de dados via protocolos de rede. Por fim, pode-se instalar pacotes manualmente, fazendo download do arquivo empacotado compactado: Basta extraí-lo e, no diretório extraído, executar o arquivo <i>./configure</i>, após isso realizar o comando <i>make</i>, seguido do comando <i>make install</i>, seguido do <i>make clean</i>. Além disso, pode-se baixar manualmente o repositório do software diretamente do Github/GitLab (Pull), seguindo as especificidades da instalação de tal.</p>
                    <h4>Funcionamento</h4>
                    <p>Um gerenciador de pacotes tem a função de organizar os pacotes baixados nos respectivos diretórios da distro. Como por exemplo, ao baixarmos o htop, o gerenciador de pacotes responsável fará a organização de seus pacotes:</p>
                    <ul>
                        <li>Confs -&gt; etc/</li>
                        <li>Comando -&gt; bin/</li>
                        <li>Bibliotecas -&gt; lib/</li>
                        <li>Comandos admin -&gt; sbin/</li>
                        <li>Processo -&gt; proc/</li>
                    </ul>
                    <p>Gerenciadores de pacotes de baixo nível, como o <i>dpkg</i>, não possuem tratamento de dependências. Dessa forma, precisa-se instalá-las manualmente a cada instalação dependente/necessária. Gerenciador de pacotes de alto nível, como o <i>apt</i> (Advanced Packaging Tool), farão isso de forma automática, através dos repositórios/mirrors (<i>/etc/apt/sources.list</i> ou diretório <i>/etc/apt/sources.list.d</i>), instalando-as juntamente com a instalação principal. Existem repositórios via url http ou ftp e repositórios locais (cdrom, hd). Caso o arquivo sources.list for destruído, há um arquivo modelo em <i>/usr/share/doc/apt/examples/sources.list</i>. Repositórios seguem a seguinte sintaxe: <i>tipoPacote protocoloAcesso:enderecoPacote versaoDistro sessaoUso</i> (Exemplo1: deb http://ppa.launchpad.net/kdenlive/kdenlive-stable/ubuntu focal main) (Exemplo2: deb cdrom:[Linux Mint 20.3 _Una_ - Release amd64 20220104]/ focal contrib main). Existem 2 tipos de pacotes, <b>deb</b> e <b>deb-src</b> que aponta código fonte. O protocolo de acesso pode ser <b>http</b>, <b>ftp</b>, onde será possível indicar, no endereço do pacote, a indicação local .iso <b>file</b>. A versão da distro pode ser dada por codinome ou pela versão (Stable, Testing...). Por fim, a sessão dos pacotes, que podem ser <b>main</b> (Apenas pacotes free), <b>contrib</b> (Contém dependências de software proprietário) e <b>nonfree</b> (Código fonte fechado). A leitura/atualização dos repositórios pela distro é feito via comando <i>apt update</i>.</p>
                    <h4>Gerenciadores de Alto Nível</h4>
                    <p><b>apt / aptitude:</b><br>O gerenciador apt utiliza base de dados própria de pacotes. Com relação ao apt-get, o <i>aptitude</i> possui alguns privilégios extra, mas ambos executam exatamente a mesma função. Uma das diferenças é que o aptitude mostra, em pesquisa, os programas já instalados no dispositivo. Mais especificamente, mostrará legenda se o programa encontra-se instalado(i), verbose/versão(v), não instalado(p). Para pesquisar programas, basta informar o comando <i>aptitude search nomePrograma</i>. Algumas distros não possuem aptitude instalado nativamente, mas o mesmo pode ser instalado via apt. Sintaxe: <i>aptitude install -d -f -s -u -y --reinstall</i>.</p>
                    <ul>
                        <li><b>-d:</b> Download-only, realiza apenas o download, não instala. Os pacotes ficam disponíveis em <i>/var/cache/apt/archives</i></li>
                        <li><b>-f:</b> Fix broken, corrige erros gerados na instalação de pacotes</li>
                        <li><b>-s:</b> Simulate, simula o processo de instalação, não realizando-a de fato</li>
                        <li><b>-u:</b> Show upgrade, exibe lista de pacotes que serão atualizados</li>
                        <li><b>-y:</b> Assume yes, assume confirmação da instalação diretamente</li>
                        <li><b>--reinstall:</b> Reinstala o pacote já instalado</li>
                    </ul>
                    <p>No caso do apt, o comando para verificar se o gerenciamento de pacotes está de acordo é <i>apt-get check</i>. Esse comando identifica e corrige falhas da família apt. Para atualizar os pacotes via aptitude, como no apt, basta informar <i>aptitude safe-upgrade</i>, podendo informar as flags acima para complementar, inclusive o mesmo ocorre para o apt. Para ajustar pacotes quebrados em geral, pode-se utilizar <i>apt-get -f install</i>. Para acessar a interface de gerenciamento de pacotes com aptitude, basta informar <i>aptitude</i>. Para esvaziar os arquivos de repositórios, basta informar <i>aptitude clean</i> ou <i>apt-get clean</i>. Para procurar informações sobre pacote, pode utilizar <i>aptitude info nomePacote</i> ou <i>aptitude show nomePacote</i>. Informando <i>apt moo</i>, você verá o 'vaca', informando somente <i>apt</i> ou <i>apt-get</i> você verá que o mesmo terá poderes de 'Super Vaca'.</p>
                    <p><b>YUM</b><br>O YUM é o gerenciador de pacotes pertencente às distros Red Hat (.rpm). É muito similar ao apt. Seu arquivo de configuração está em <i>/var/cache/yum</i>. Seus repositórios ficam em <i>/etc/yum.repos.d</i>. Os repositórios sempre possuem o final <i>.repo</i>. Além dos comandos similares ao apt, o yum possui o <b>providers</b>, que exibe qual o pacote fornecerá o recurso/arquivo determinado, independente se o mesmo estiver instalado ou não. No caso do update, tem-se o comando <i>update --obsoletes</i>, onde há verificação dos pacotes obsoletos. Há o <i>yumdownloader</i>, onde é realizado somente o download do pacote, não instalando o mesmo. Por fim, tem-se a opção <b>--source</b>, no qual copia o código fonte do pacote, ao invés do mesmo ser compilado. Para pesquisas, além dos conhecidos advindos do apt, tem-se também o <i>YUM list</i>, que trará a listagem somente do argumento de busca, sendo mais objetivo que o <i>search</i>. Para a remoção de pacotes, além dos conhecidos no apt, tem-se o <i>YUM erase nomePacote</i>, que também fará a remoção do mesmo.</p>
                    <p><b>dnf</b><br>O dnf (Dandified YUM) é o gerenciador de pacotes, geralmente o principal, utilizado no Fedora e demais distros Red Hat, sendo um fork do YUM, funcionando da mesma maneira que tal. O dnf utiliza Python 3, enquanto o YUM a versão 2.</p>
                    <p><b>zypper</b><br>O ZYpp é o gerenciador de pacotes de distros SUSE, utilizando gerenciamento de pacotes rpm, distribuindo pacotes na mesma. Possui utilização similar ao YUM, com alguns argumentos extras, como <b>list-updates</b>, <b>verify</b>, <b>what-providers</b>, <b>refresh</b>.</p>
                    <p><b>synaptic</b><br>Gerenciador de pacotes criados por Brasileiros para uso em conjunto com o sistema de empacotamento Codecs, funcionando como, basicamente, um front-end para o apt, que serve para manipulação de repositórios, para baixar instalações de pacotes. Serve mais para atualização de pacotes em geral, assim como até mesmo a Distro em si.</p>
                    <p><b>snap</b> e <b>flatpack</b><br>Sistemas de empacotamento universal para repositórios. Com algum desses atualizados em qualquer distro, haverá a compatibilidade e simplicidade no processo de instalação, mesmo em Debian e Red Hat. Como Stores GUI para facilitar a instalação, tem-se a <b>Snapstore</b>, <b>Snapcraft</b>, <b>Gnome Software</b>, <b>Flathub</b>, entre outras. Existem Stores de determinadas distros, como no ZorinOS, que combinam os gerenciadores snap e flatpack, onde o usuário pode selecionar a origem de seus pacotes a cada instalação.</p>
                    <p><b>appimage</b><br>Assim como snap e flatpack, o appimage funciona como um container de aplicações para fácil instalação e compatibilidade nas mais diversas distros Linux. O appimage não requer permissões root para proceder, não precisando instalar o pacote, apenas baixá-lo e sair usando-o. O software AppImageLancher auxilia na instalação GUI de pacotes appimage. A instalação de pacotes, de forma CLI, acontece pelo comando <i>sudo ./nomePacote.appimage --install</i>.</p>
                    <p><b>wget</b><br>Permite baixar arquivos via HTTP, HTTPS e FTP. Ex: <i>wget http://ftp.gnu.org/pub/gnu/wget/wget-1.10.1.tar.gz</i></p>
                </div>
            </div>
            <br>

        </div>
    </div>


<!--Rodapé-->
<div class="row">
    <div class="col-sm-12 text-center bg-black text-light pt-4 pb-3">
        <p>Elaborado por Mateus Schwede<br><small class="text-muted">ubsocial.github.io</small></p>
    </div>
</div>

</div>
</body>
</html>