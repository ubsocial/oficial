<!doctype html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="../../icons/logoTit.png">
    <link rel="stylesheet" href="../../estilo.css">
    <title>UB Social</title>
</head>
<body>
<div class="container-fluid">


    <div class="row">
        <div class="col-sm-12">
            <nav class="navbar rounded-bottom fixed-top navbar-expand-lg navbar-light bg-light shadow">
                <div class="container-fluid">
                    <a class="navbar-brand" href="../../index.html"><img src="../../icons/logo.png" class="d-inline-block align-text-top" width="11pt"> UB Social</a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                    <div class="collapse navbar-collapse" id="navbarNav">
                        <ul class="navbar-nav">
                            <li class="nav-item"><a class="nav-link" href="../../index.html">Home</a></li>
                            <li class="nav-item"><a class="nav-link" href="../../livros/livros.html">Livros</a></li>
                        </ul>
                    </div>
                </div>
            </nav>
        </div>
    </div>

    <div class="row">
        <div class="col-sm-12 text-center" id="titulo">
            <img src="gnome.png" class="img-fluid mb-3" width="400px">
            <h1>Linux</h1>
            <h6><strong>Conceitos técnicos e gestão prática</strong></h6>
            <a href="../../index.html" class="btn btn-link text-decoration-none mb-3">Voltar</a><br>
            <a href="https://youtube.com/playlist?list=PLnPZ9TE1Tj4DMd5YpzLGUI2y33Adh57bJ" class="btn btn-link text-decoration-none mb-3" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" width="1.3em" height="1.3em" fill="currentColor" class="bi bi-youtube text-danger" viewBox="0 0 16 16"><path d="M8.051 1.999h.089c.822.003 4.987.033 6.11.335a2.01 2.01 0 0 1 1.415 1.42c.101.38.172.883.22 1.402l.01.104.022.26.008.104c.065.914.073 1.77.074 1.957v.075c-.001.194-.01 1.108-.082 2.06l-.008.105-.009.104c-.05.572-.124 1.14-.235 1.558a2.007 2.007 0 0 1-1.415 1.42c-1.16.312-5.569.334-6.18.335h-.142c-.309 0-1.587-.006-2.927-.052l-.17-.006-.087-.004-.171-.007-.171-.007c-1.11-.049-2.167-.128-2.654-.26a2.007 2.007 0 0 1-1.415-1.419c-.111-.417-.185-.986-.235-1.558L.09 9.82l-.008-.104A31.4 31.4 0 0 1 0 7.68v-.123c.002-.215.01-.958.064-1.778l.007-.103.003-.052.008-.104.022-.26.01-.104c.048-.519.119-1.023.22-1.402a2.007 2.007 0 0 1 1.415-1.42c.487-.13 1.544-.21 2.654-.26l.17-.007.172-.006.086-.003.171-.007A99.788 99.788 0 0 1 7.858 2h.193zM6.4 5.209v4.818l4.157-2.408L6.4 5.209z"/></svg> Conteúdo disponível</a>
        </div>
    </div>

    <div class="row">
        <div class="col-sm-12">

            <div class="card mb-4">
                <h4 class="card-header">Fundamento</h4>
                <div class="card-body">
                    <p>Criado em 1991 por Linus Torvalds, Linux não é um SO completo. É um kernel livre baseado em Unix (Ken Thompson e Dennis Ritchie), Minix, desenvolvido em C, considerado, inicialmente, um emulador de terminal para uso em Unix. Através de Richard Stallman, Linus conhece o projeto GNU, onde, futuramente, licencia o kernel Linux (GNU/Linux). Sua 1ª distribuição comercial foi a Yggdrasil Linux/GNU/X, lançada em 1992, no formato Live CD. O mascote do Linux é o pinguim Tux (Torvalds' Unix ou Tuxedo). Atualmente, 90% dos servidores web são Linux, correspondendo 99% dos supercomputadores no mundo. Linux está presente na maior parte de nossa rotina, como em dispositivos embarcados (smart TVs, Android, MacOS, video games, eletrodomésticos, multimídias automotivas, caixas eletrônicos), órgãos governamentais (forças armadas, departamentos governamentais), aplicações críticas (trens bala, CERN, sistemas de tráfego aéreo, reatores nucleares, foguetes de sondagem, artilharias de guerra), entre outros. Isso ocorre porque o Linux é Free (livre), onde não há restrição legal para manuseamento do código, permitindo, dessa forma, personalização profunda, de acordo com a necessidade. Além disso, o kernel possui enorme comunidade de contribuidores, ocasionando frequentes atualizações de integridade e otimização. Seu código fonte está disponível em <a href="https://www.kernel.org" class="text-decoration-none" target="_blank">kernel.org</a>. Principais órgãos certificadores são LPI (Linux Professional Institute), Red Hat e The Linux Foundation. Esse resumo prepara você para concluir a certificação LPI Linux Essentials, a certificação básica do LPI. Tais certificações são reconhecidas mundialmente. Software livre (free software) possui código aberto (open source) e segue as diretrizes da GPL. Free refere-se ao conceito de liberdade, não ao preço de gratuidade (FOSS - Free and Open Source Software, FLOSS - Free/Libre and Open Source Software, sendo FLOSS a maneira mais correta, SL/CA - Software Livre e de Código Aberto). A criação da organização Creative Commons (CC), juntamente com suas licenças, disponibiliza maior diversificação de regras nos direitos autorais do mesmo, permitindo maior cooperação do projeto com a comunidade. Licenças baseadas em Creative Commons são as mais utilizadas na web.. Nem todo software open source (código aberto) é free software, nem mesmo gratuito. Customização, suporte, treinamento e serviços terceiros sob free software podem ser cobradas. Manifesto GNU (GNU not Unix) foi atrelado a FSF (Free Software Foundation), criados por Stallman para armazenar a GPL (GNU General Public License), que possui 4 liberdades:</p>
                    <ol start="0">
                        <li><b>Executar</b> o software para qualquer propósito ou finalidade;</li>
                        <li><b>Estudar</b> o funcionamento interno do software, podendo fazer alterações e adaptações conforme necessidade;</li>
                        <li><b>Modificar</b> e melhorar o software, para que a comunidade possa beneficiar-se das mesmas;</li>
                        <li><b>Distribuir</b> o software, contanto que a distribuição seja com as mesmas liberdades que o software recebido, como não fechar o código.</li>
                    </ol>
                    <p>Licenças como essas são Copyleft. A LGPL (GNU Lesser General Public License) foi escrita como meio-termo da GPL, permitindo associação com softwares que não estejam sob licenças GPL e LGPL, incluindo software proprietário. A AGPL (GNU Affero General Public License) cobre venda de acesso a software hospedado. A FDL (GNU Free Documentation License) estende princípios da liberdade à documentação do software. Licença permissiva, contrária à Copyleft, permite ao proprietário criar suas próprias cláusulas.</p>

                    <h5>Estrutura de sistema Linux:</h5>
                    <ol>
                        <li><b>Hardware</b>: Componentes físicos do dispositivo;</li>
                        <li><b>Kernel Linux</b>: Núcleo do sistema operacional. Mediador entre hardware e camadas superiores;</li>
                        <li><b>Sistema Operacional</b>: Auxilia e hospeda aplicações das camadas superiores;</li>
                        <li><b>Terminais Virtuais</b> (tty1..6): Interpretam comandos e convertem para linguagem de máquina. Camada de execução de comandos e configurações;</li>
                        <li><b>Servidor Gráfico</b>: Base de implantação do ambiente gráfico (GUI). Entre os principais, tem-se Xorg (X ou X11) e Wayland (Wayland Compositor);</li>
                        <li><b>Display Manager</b>: Gerencia logins na GUI e seleciona tipo de GUI que será executada;</li>
                        <li><b>Desktop</b>: Camada que hospeda aplicações dependentes de GUI para funcionamento.</li>
                    </ol>

                    <h5>Tipos de kernel Linux:</h5>
                    <ul>
                        <li><b>Generic (Stable)</b>: Padrão de SOs Linux;</li>
                        <li><b>LTS (Longterm)</b>: Maior suporte e estabilidade;</li>
                        <li><b>Zen</b>: Open Source, fork do Generic, objetivo de otimização;</li>
                        <li><b>Liquorix</b>: Similar ao Zen, objetivo de otimização para games e mídia;</li>
                        <li><b>Hardened</b>: Open Source, objetivo de segurança e robustez, menos performance;</li>
                        <li><b>XanMod</b>: Objetivo de performance.</li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Distros</h4>
                <div class="card-body">
                    <p>Uma distribuição (distro) Linux é um SO com kernel Linux (GNU/Linux). Atualmente, há cerca de 600 distros, nem todas gratuitas. As distros base (from scratch) são Slackware, Debian, Red Hat Enterprise Linux (RHEL), Gentoo, SUSE e Arch. Com isso, criou-se uma árvore de distros geradas a partir de suas progenitoras (<a href="https://commons.wikimedia.org/wiki/File:Linux_Distribution_Timeline_27_02_21.svg" class="text-decoration-none" target="_blank">timeline distros Linux</a>). Como exemplo, o Ubuntu é baseado no Debian, o Mint é baseado no Ubuntu. O Fedora e o CentOS são versões free do RHEL. O <a href="https://distrowatch.com" class="text-decoration-none" target="_blank">distrowatch</a> possui todas notícias sobre distros Linux. A versão não modificada do kernel Linux é chamada de 'Vanilla'. A distro mais antiga em atividade é o Slackware.</p>
                    <ul>
                        <li>Distros <b>versionadas</b> (lançamentos versionados);
                            <ul>
                                <li>LTS (long term support): Possui atualizações menos frequentes e pacotes mais estáveis;</li>
                                <li>testing: Versão não LTS, possui as mais recentes atualizações publicadas;</li>
                                <li>unstable: Possui as atualizações mais recentes e que ainda não foram publicadas (beta).</li>
                            </ul>
                        </li>
                        <li>Distros <b>rolling release</b> (lançamentos contínuos, atualizações constantes, ausência de versionamento).</li>
                    </ul>
                    
                    <h5>GUI e CLI:</h5>
                    <p>Toda distro é <b>CLI</b> (command-line interface), onde há ausência de interface gráfica, sendo somente modo texto. Servidores geralmente utilizam somente CLI. Distros com adesão de GUI (graphical user interface) possuem interface gráfica, sendo essa renderizada através de <b>desktop environment</b> (DE). Desktop environment engloba a interface gráfica do gerenciador de janelas, além de seus respectivos softwares. Os DEs são diferentes no que diz respeito a uso de recursos de hardware no dispositivo, customização e aparência. Entre os principais gerenciadores de janelas, tem-se:</p>
                    <ul>
                        <li>Gnome (GNU network object model environment): Principal DE Linux, possui widget toolkit GTK e servidores gráficos Xorg e Wayland. Caracteriza-se por ser mais responsivo e completo. Portanto, consome mais recursos de hardware do dispositivo;</li>
                        <li>KDE (K desktop environment): Utiliza widget toolkit Qt. Caracteriza-se por ser extremamente customizável e consome poucos recursos de hardware do dispositivo;</li>
                        <li>XFCE (XForms common environment): Caracteriza-se por ser mais estável e consumir menos recursos de hardware do dispositivo. Utiliza servidor gráfico Xorg;</li>
                        <li>MATE (MATE advanced traditional environment): Nome advindo da 'erva-mate', caracteriza-se por ser leve e customizável;</li>
                        <li>LXDE (Lightweight X11 desktop environment): Caracteriza-se por consumir pouquíssimos recursos de hardware do dispositivo;</li>
                        <li>LXQt (LXDE + Qt): Utiliza widget toolkit Qt, caracteriza-se por consumir pouquíssimos recursos de hardware do dispositivo;</li>
                        <li>Cinnamon: Caracteriza-se por ser extremamente similar ao Windows. Consome poucos recursos de hardware do dispositivo;</li>
                        <li>Fluxbox: Caracteriza-se por consumir pouquíssimos recursos de hardware do dispositivo;</li>
                        <li>Deepin DE (desktop environment): Caracteriza-se por ser extremamente similar ao MacOS;</li>
                        <li>Pantheon: Caracteriza-se por ser extremamente similar ao MacOS;</li>
                        <li>Unity;</li>
                        <li>WindowMaker;</li>
                        <li>AwesomeWM;</li>
                        <li>Entre outros.</li>
                    </ul>
                    <p>Em muitas situações, pode-se optar por qual DE instalar na distro. Como, por exemplo, no Debian, optar entre Debian Gnome, Debian KDE, Debian XFCE, etc. Distros com DEs como XFCE, LXQt, MATE e Fluxbox são ideais para hardware obsoleto. Distros com DEs como XFCE, KDE e Cinnamon possuem mais similaridade com Windows. Distros com DEs como Pantheon e Deepin DE possuem mais similaridade com MacOS.</p>
                    <h5>Servidores:</h5>
                    <p>Dispositivos com função de prover determinados serviços, de forma segura e eficaz. Geralmente são classificados da seguinte maneira:</p>
                    <ul>
                        <li><b>Web</b>: Provê resposta requisitada pelo dispositivo cliente, via protocolo HTTP (Hypertext Transfer Protocol). Entre os principais softwares para gestão de servidor web tem-se Apache, nginx, Node.js e lighttpd;</li>
                        <li><b>Banco de dados</b>: Armazenamento e gestão de dados. Entre os principais softwares para gestão de banco de dados, tem-se Oracle DB, MySQL, SQL Server, MariaDB, PostgreSQL e MongoDB;</li>
                        <li><b>Armazenamento de dados</b>: Utilizado em dispositivos corporativos/domésticos para comunicação e armazenamento de dados. Entre dispositivos Linux, o protocolo NFS (Network File System) permite criação e acesso de diretórios remotos. Windows possui o Samba (SMB - Simple Message Block), para comunicação com outros dispositivos Linux. OwnCloud é servidor de armazenamento de dados em cloud. NextCloud é similar, possuindo funcionalidades extras, como videoconferência e funções relacionadas;</li>
                        <li><b>Arquivos</b>: Utilizados para acesso/gestão de arquivos e diretórios diretamente, via protocolo FTP (File Transfer Protocol);</li>
                        <li><b>Aplicação (Applications Server)</b>: Execução de aplicações diversas, que podem ser utilizadas de forma compartilhada, sem comprometer desempenho e integridade. Entre as principais aplicações, tem-se Java, PHP e .NET;</li>
                        <li><b>Email</b>: Gestão de emails, via protocolo SMTP (Simple Mail Transfer Protocol). Geralmente utilizado em conjunto com servidores web (servidor <b>webmail</b>);</li>
                        <li><b>Streaming</b>: Transmissão de recursos de mídia em tempo real, via padrão DLNA (Digital Living Network Alliance);</li>
                        <li><b>Backup</b>: Armazenamento seguro de cópias de dados;</li>
                        <li><b>Proxy</b>: Filtragem de requisições entre cliente e servidor (intermediador), fornecendo privacidade, onde o IP da operação é o do Proxy;</li>
                        <li><b>Jogos</b>: Execução de games, fornecendo desempenho e banda larga. Servidores <b>VPS</b> (Virtual Private Server) podem ser utilizados para tal, criando máquinas virtuais para maior desempenho;</li>
                        <li><b>DNS</b>: Fornece tradução de nomes de domínio (Domain Name Service) para IPs;</li>
                        <li><b>DHCP</b>: Gestão automatizada de fornecimento de endereços IPs (DHCP - Dynamic Host Communication Protocol);</li>
                        <li><b>Blade</b>: Servidor físico que ocupa espaços menores, muito utilizado em redes locais;</li>
                        <li><b>Impressão</b>: Gestão, em larga escala, de impressão de documentos;</li>
                        <li><b>Fax</b>: Gestão automatizada, em larga escala, de envio/recebimento de fax;</li>
                        <li><b>Sistema operacional</b>: Armazenamento de sistema operacional em máquina física, para acesso remoto e compartilhado.</li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Instalação</h4>
                <div class="card-body">
                    <p>Existem diversas formas para utilizar distros Linux. Pode-se instalá-lo diretamente na máquina (<b>bare metal</b>), via pendrive bootável (live boot), unicamente ou ao lado de outro SO já presente no dispositivo (dual boot, multi boot). Primeiramente, precisa-se baixar o arquivo .iso da distro, para posteriormente formatar o pendrive com a .iso selecionada (pendrive bootável), através de algum software específico, como balenaEtcher. Após formatação concluída, o computador precisa ser reiniciado e sua BIOS acessada (F12), para selecionar opção de boot do pendrive. Os principais instaladores de distros Linux são Anaconda (Sabayon), DI (Debian-Installer), Drakx Installer (Mandriva/Mageia), Sysinstaller, Ubiquity (Ubuntu16), Calamares (Red Hat), YaST (SUSE), etc. Outro meio para utilizar distro Linux é através de <b>VM</b> (virtual machine) com o arquivo .iso da distro. Outra alternativa é através de <b>containers</b>. Via Windows, pode-se utilizar distro Linux via <b>WSL</b> (Windows Subsystem for Linux). Por fim, pode-se utilizar distro Linux online, via plataforma <b>cloud</b>, como Amazon, Azure, GCP, etc. Distros <b>modo incógnito</b> são live USB que são executadas na memória RAM do dispositivo, com processamento e armazenamento volátil, ou seja, removido após desligamento do dispositivo.</p>

                    <h5>Tipos de instalação (iso):</h5>
                    <ul>
                        <li><b>USB</b>: Geralmente associada à pendrive bootável, para instalação/teste no dispositivo;</li>
                        <li><b>Live</b>: Geralmente associada à Live USB, para utilizar a distro sem necessidade de instalação. Leve;</li>
                        <li><b>CD</b>: Geralmente mais leve, possui menos recursos, geralmente necessita de internet para instalação de demais programas, ou descartando, dependendo do tamanho do CD. Geralmente instalação mais direta que USB;</li>
                        <li><b>DVD</b>: Geralmente mais pesada, possui todos os recursos para instalação, geralmente descartando internet. Mais pesada que o comum;</li>
                        <li><b>NetInstall</b>: Geralmente associada, ou à USB ou à pequeno CD, para instalação totalmente dependente de internet. Extremamente leve;</li>
                        <li><b>non-free</b>: Imagem completa, contendo, inclusive, toda gama de conectores de hardware de todos fabricantes. Geralmente a mais pesada;</li>
                        <li><b>Netboot</b>: Forma de instalação. Geralmente associada à instalação direta, via rede TFTP, DHCP/BOOTP/RARP, utilizando PXE e TFTP;</li>
                        <li><b>Torrent</b>, <b>Container</b>, <b>ARM</b>, <b>Cloud</b>, <b>VM</b>, <b>Mobile</b>, <b>Build Scripts</b>: Outras formas de instalação, sendo build scripts os arquivos de códigos.</li>
                    </ul>

                    <h5>Particionamento de disco:</h5>
                    <p>Objetivo do particionamento é separar, ao máximo, as finalidades dos diretórios com relação ao dispositivo de armazenamento, facilitando assim a manutenção, em caso de falhas/erros em uma partição, onde as demais permanecerão intactas.</p>
                    <p><b>Desktop</b>:<br>Particionamento de disco com 500GB disponíveis para armazenamento e 4GB de RAM, para instalação de Ubuntu 20. Formatação do tipo GPT (GUID Partition Table) ou MBR (Master Boot Record), será da seguinte forma:</p>
                    <ul>
                        <li><b>Boot</b>: Partição para boot da distro, tipo primária FAT32, com label <i>/boot/efi</i>, com média de 800MB;</li>
                        <li><b>Swap</b>: Partição de memória virtual, tipo primária linux-swap, sem label, com média de metade do tamanho da RAM ou mais (aqui no caso 2GB);</li>
                        <li><b>Root</b>: Partição raíz, onde ficará o sistema, tipo primária journaling EXT4 (ou BTRFS), com label <i>/</i>, preenchendo com o restante do espaço livre.
                            <ul>
                                <li><span class="text-muted">Opcional</span> (Partição <b>home</b> separada): Partição onde ficarão os arquivos dos usuários (documentos, imagens, vídeos, etc), do tipo primária journaling EXT4, com label <i>/home</i>, preenchendo com o espaço livre restante (Neste caso, 40% do espaço livre restante será de home, e os demais 60% será de root);</li>
                                <li><span class="text-muted">Opcional</span> (<b>criptografa</b>): Pode-se criptografar a participação root com o LUKS (Linux Unified Key Setup-on-disk-format. Ferramentas como Dm-crypt e Cryptsetup realizam tal procedimento em discos já formatados).</li>
                            </ul>
                        </li>
                    </ul>
                    <p><b>Servidor</b>:<br>Particionamento de disco com 40GB, em modo antigo MBR BIOS (não EFI, onde criaria somente partições primárias).</p>
                    <img src="partServidor.png" class="img-fluid rounded" width="350px">
                    <ul>
                        <li><b>Boot</b>: Tipo primária, localização início, journaling EXT4, ponto de montagem <i>/boot</i>, com média de 1GB;</li>
                        <li><b>Swap</b>: Tipo primária, localização início, swap, com média de 2GB;</li>
                        <li><b>LVM</b>: Tipo lógica, localização início, volume físico LVM, com média de 15GB (logical volume management, faz tamanho da partição ser dinâmico (criação de volumes lógicos), sem perda de dados);</li>
                        <li><b>usr</b>: Tipo lógica, localização início, journaling XFS, ponto de montagem <i>/usr</i>, com média de 20GB;</li>
                        <li><b>tmp</b>: Tipo lógica, localização início, journaling EXT4, ponto de montagem <i>/tmp</i>, opção de montagem 'noexec' (não permite executar binários), com média de 1GB;</li>
                        <li><b>Root</b>: Tipo lógica, localização início, journaling EXT4, ponto de montagem <i>/</i>, com média de 10GB;</li>
                        <li><b>var</b>: Configurar LVM, criando grupo de volumes (nome 'system'), selecionar partição LVM acima. Com isso, criar volume lógico, grupo 'system' (nome 'var'), tamanho restante disponível. Selecionar volume lógico e usar como journaling XFS, ponto de montagem <i>/var</i>;</li>
                        <li><b>Espaço livre</b>: Conforme finalidade do servidor. Partição tamanho total, tipo lógica, ponto de montagem <i>/var/www</i> para servidor Apache, ou <i>/home</i> para desktop, ou <i>/var/mysql</i> para servidor MySQL, ou <i>/srv/samba</i> para servidor de arquivos.</li>
                    </ul>
                    <p>Toda distro Linux possui codecs (compatibilizadores de formatos de mídia), pode-se configurar snapshots via gerenciador de backups Timeshift, realizar tarefas agendadas de Cron/Crontab, UFW (Ubuntu firewall) e GUFW (Graphical), gestão de configurações Tweaks, entre outras funcionalidades. Há possibilidade de executar softwares incompatíveis com Linux via softwares interpretadores, como <b>Wine</b> (Wine is not emulator) e <b>PlayOnLinux</b>, através da implementação livre da API do Windows e engenharia reversa.</p>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Estrutura</h4>
                <div class="card-body">
                    <p>No Linux não existem programas, drivers e extensões: Tudo é considerado arquivo. Dispensando conceito de 'pasta', a estrutura de diretórios de arquivos no Linux possui padrão POSIX, baseada em FHS (File system Hierarchy Standard). Até mesmo os componentes de hardware são controlados por arquivos em realtime. Nos caminhos de diretórios, tem-se o <i>caminho absoluto</i> (originado a partir do diretório raíz até o diretório atual, exemplo: <span class="text-muted">/home/ubsocial/arquivo</span>. Comando 'pwd' mostra caminho absoluto - print world directory) e caminho relativo (originado a partir de diretório qualquer até o diretório atual (não originado no diretório '/'), exemplo <span class="text-muted">ubsocial/arquivo</span>).</p>
                    <ul>
                        <li>Diretório root: <b>/</b> <span class="text-muted">(cd /)</span></li>
                        <li>Diretório home: <b>~</b> <span class="text-muted">(cd ~)</span> o mesmo que '/home/usuarioSessao'</li>
                        <li>Diretório atual: <b>.</b> <span class="text-muted">(cd .)</span></li>
                        <li>Diretório pai: <b>..</b> <span class="text-muted">(cd ..)</span></li>
                        <li>Diretório anterior: <b>-</b> <span class="text-muted">(cd -)</span></li>
                    </ul>
                    <p>Todo arquivo oculto inicia com ponto (<b>.</b>) antes do nome. Diretórios possuem barra (<b>/</b>) no final do nome (por convenção, geralmente possuem '.d' no final do nome, nos casos em que o diretório possuir arquivos de serviço específico). Diretórios com <b>@</b> no final do nome são links simbólicos, ou seja, atalhos para o diretório real. Diretórios como /bin, /sbin, /etc, /lib devem estar na mesma partição que '/'.</p>

                    <h5>Estrutura de diretórios:</h5>
                    <ul>
                        <li><b>/</b> (root): Diretório raíz, progenitor de todos os demais, onde encontram-se os diretórios abaixo;</li>
                        <li><b>/bin</b>: Possui todos os binários (binaries), comandos/alias do shell, disponíveis aos usuários comuns. Link simbólico para '/usr/bin'. Exemplo, alias 'ls' refere-se a '/bin/ls', ou seja, '/usr/bin/ls';</li>
                        <li><b>/boot</b>: Arquivos estáticos para inicialização (boot) do Linux, como gerenciador GRUB e imagem do kernel;</li>
                        <li><b>/cdrom</b>: Diretório legado (não pertence a FHS), para montagem temporária de imagem de CD-DVD. Local atual para tal é '/media';</li>
                        <li><b>/dev</b>: Arquivos de dispositivos (devices) de entrada e saída, como periféricos, como hd (sda, vda), ssd e usb (sda, sdb), cdrom, disquete floppy (fd) e tty;</li>
                        <li><b>/etc</b>: Abreviação de 'etcetera' ou 'edit do/to config'. Arquivos de configuração do sistema, como scripts de inicialização, módulos de programas, tabela de sistema de arquivos (fstab - file system table), configurações de services e usuários;</li>
                        <li><b>/home</b>: Diretórios dos usuários do sistema. Cada usuário é representado por diretório com seu nome, contendo seus respectivos arquivos dentro (área de trabalho, documentos, imagens, etc);</li>
                        <li><b>/lib, /lib32, /libx32, /lib64</b>: Bibliotecas (libraries) compartilhadas e módulos do kernel. Libraries são scripts que podem ser utilizados por outros arquivos dependentes para seu funcionamento. Links simbólicos para '/usr/lib', '/usr/lib32', 'usr/libx32' e '/usr/lib64';</li>
                        <li><b>/lost+found</b>: Diretório geralmente oculto (/.lost+found) de 'achados e perdidos' (não faz parte da FHS), usado para reparos gerais no sistema, como comando 'fsck';</li>
                        <li><b>/media</b>: Ponto de montagem para mídias removíveis (media), como cdrom, floppy, webcam, usb, hd e ssd externos;</li>
                        <li><b>/mnt</b>: Ponto de montagem temporária (mount) de sistema de arquivos, como outros SOs e cdrom (similar ao '/media');</li>
                        <li><b>/opt</b>: Abreviação de 'optional', utilizado por arquivos proprietários, não licenciados pela GNU, adicionados pelos usuários;</li>
                        <li><b>/proc</b>: Processos (process) do Linux e todas informações do hardware (cpu, memória e partições), módulos carregados no kernel ('/proc/modules') e configurações do kernel ('/proc/sys/'). Diretório virtual (gravado em RAM, volátil, todos arquivos nele são apagados no desligamento do dispositivo);</li>
                        <li><b>/root</b>: Arquivos do usuário administrador (root, 'home do root'), para administração de interface de rede, usuários e grupos, prioridades, entre outros;</li>
                        <li><b>/run</b>: Diretório virtual de arquivos temporários sensíveis de inicialização do sistema, além de informações de services em execução (run, runtime);</li>
                        <li><b>/sbin</b>: Link simbólico para '/usr/sbin', possui os super binários (super binaries ou system binaries), comandos/alias do administrador do Linux (root), utilizados para inicialização, reparação e restauração do sistema, e informações sensíveis de rede. '/usr/local/sbin' armazena super binários instalados localmente, que não são gerenciados pelo gerenciador de pacotes. '/usr/local/bin' é similar, porém voltado aos binários comuns;</li>
                        <li><b>/srv</b>: Serviços (service) do Linux, como rede, acessíveis externamente. Geralmente utilizado para instalação de servidores web ('/srv/www'), samba ('/srv/samba') e ftp ('/srv/ftp');</li>
                        <li><b>/sys</b>: Diretório virtual de mapeamento de chamadas diretas ao kernel (system), sistema de arquivos sys (sysfs), e informações sobre devices e módulos, sendo similar ao '/proc', porém mais organizado e categorizado;</li>
                        <li><b>/tmp</b>: Diretório virtual de arquivos temporátios (temp, temporary);</li>
                        <li><b>/usr</b>: Recursos do Linux (user, unix system resources), como libraries e binaries, scripts do kernel ('/src'), documentação ao usuário, além de arquivos não essenciais ao sistema, que seguem padrão GNU. Considerado segunda hierarquia do FHS;</li>
                        <li><b>/var</b>: Arquivos de informações e tamanho variável (variable), como cache, email, logs e impressão ('/spool').</li>
                    </ul>

                    <h5>Camadas distro Linux:</h5>
                    <ol>
                        <li><b>Hardware</b>: Componentes físicos do dispositivo;</li>
                        <li><b>Kernel Linux</b>: Núcleo mediador entre hardware e camadas superiores;</li>
                        <li><b>Sistema operacional</b>: Camada que auxilia e hospeda todos arquivos das camadas superiores;</li>
                        <li><b>Teletypes</b> (tty1, tty2, tty3, tty4, tty5, tty6...63): Terminais virtuais, responsáveis por interpretar os comandos (binaries);</li>
                        <li><b>DM</b> (display manager): Gerenciamento de login e ambiente gráfico;</li>
                        <li><b>Desktop environment</b>: Ambiente GUI de hospedagem dos programas.</li>
                    </ol>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">File systems e devices</h4>
                <div class="card-body">
                    <h5>File systems:</h5>
                    <p>File system tem objetivo de gerenciar os bytes de dados no dispositivo.</p>
                    <ul>
                        <u>Microsoft</u>:
                        <li><b>FAT32</b> (File allocation table): Utilizado em Windows, não suporta journaling;</li>
                        <li><b>exFAT</b> (Extensible FAT): Alternativa ao FAT, melhor compatibilidade entre diferentes file systems. Possui pouquíssimos recursos e suporta arquivos de tamanhos diversos. Ideal para pendrives e HDs externos que acessam diferentes file systems;</li>
                        <li><b>NTFS</b> (New technology file system): Evolução do FAT32, suporte de volumes maiores, possui checksums em journaling e snapshots em volume shadow copy. Compatível com leitura de dados em outros file systems, mas com compatibilidade de escrita instável;</li>
                        <u>Linux</u>:
                        <li><b>ext4</b> (Fourth extended file system): Mais popular em dispositivos Linux "domésticos", possui checksums em journaling;</li>
                        <li><b>ZFS</b> (Zettabyte file system): Gerencia vários volumes (pool), checksums próprios e confiáveis, snapshots e copy on write (COW). O openZFS é a versão free do ZFS. Utilizado em servidores;</li>
                        <li><b>BTRFS</b> (B-tree file system): Simimlar ao ZFS, com otimizações e aberto. Ideal para servidores.</li>
                    </ul>

                    <h5>Devices:</h5>
                    <p>Linux possui 3 formatos de gerenciamento de dados: <b>stdin</b> 0 (standard input, entrada de dados, como via teclado), <b>stdout</b> 1 (standard output, saída de dados, como via display tela) e <b>stderr</b> 2 (standard error, feedback de erro, como via display tela ou arquivo de log). Pode-se alterar o padrão, como redirecionar stderr para arquivo ('<span class="text-muted">ls erro 2&gt; arquivo</span>'). Redirecionar stdout e stderr para mesmo local com '<span class="text-muted">ls -l ubsocial 2&&gt;1 arquivo</span>'. Redirecionar stdout e stderr para locais diferentes com '<span class="text-muted">ls -l ubsocial &gt; arquivo 2&gt; arquivoErros</span>'. O diretório '/dev' armazena arquivos dos dispositivos periféricos, com exceção de placas de rede, que são carregadas via módulo do kernel. Em '/dev' há '/devfs' ou '/udev'. '/dev' carrega todos os módulos ("drivers") do Linux, incluindo os não presentes no hardware host. '/udev' carrega somente módulos encontrados no hardware host, além da configuração automatizada codeplug e hotplug. Seu arquivo de configurações é '/etc/udev/udev.conf' e seus arquivos de regras (rules) estão em '/etc/udev/rules.d/'. Os comando <i>udevmonitor</i> e <i>udevadm monitor</i> permitem modificar eventos armazenados no sistema lógico sysfs, onde ficam as identificações dos dispositivos.</p>
                    
                    <h5>Tipos de devices:</h5>
                    <ul>
                        <li><b>Caractere</b> (c): Orientados à comunicação e fluxo de informações de modo serial, ou seja, caractere a caractere. Utilizados por comunicações entre portas seriais ou paralelas, como modens, e tty's (comunicação com o kernel);</li>
                        <li><b>Bloco</b> (block): Orientados ao armazenamento de informações temporárias de mídia. Geralmente utilizado para representar partições, hd's (sda ou vda) e pendrives;</li>
                        <li><b>FIFO</b> (first in, first out): Processamento de dados em formato de fila, viabilizando comunicação entre dois processos independentes;</li>
                        <li><b>Socket</b>: Voltados à criação de ponto de comunicação.</li>
                    </ul>

                    <h5>Diretórios dos devices:</h5>
                    <ul>
                        <li><b>/dev/fd0</b> e <b>/dev/fd1</b>: Respectivamente, 1ª e 2ª unidade de disquete (floppy disk);</li>
                        <li><b>/dev/hda</b> e <b>/dev/hdb</b>: Dispositivos HD IDE master (hda) e slave (hdb);
                            <ul>
                                <li><b>/dev/hda1</b>: 1ª partição do 1º dispositivo IDE master;</li>
                                <li><b>/dev/hda2</b>: 2ª partição do 1º dispositivo IDE master, e assim por diante;</li>
                                <li><b>/dev/hdb1</b>: 1ª partição do 2º dispositivo IDE master;</li>
                                <li><b>/dev/hdb2</b>: 2ª partição do 2º dispositivo IDE master, e assim por diante;</li>
                            </ul>
                        </li>
                        <li><b>/dev/sda</b> e <b>/dev/sdb</b>: Respectivamente, 1º e 2º dispositivo SSD SATA;
                            <ul>
                                <li><b>/dev/sda1</b>: 1ª partição do 1º dispositivo SATA/SCSI;</li>
                                <li><b>/dev/sda2</b>: 2ª partição do 1º dispositivo SATA/SCSI, e assim por diante;</li>
                                <li><b>/dev/sdb1</b>: 1ª partição do 2º dispositivo SATA/SCSI;</li>
                                <li><b>/dev/sdb2</b>: 2ª partição do 2º dispositivo SATA/SCSI, e assim por diante;</li>
                                <li><b>/dev/xt1</b>: 1ª partição do 1º dispositivo MFM, e assim por diante;</li>
                                <li><b>/dev/sdd</b>: Cartões que seguem padrão SATA/SCSI;</li>
                            </ul>
                        </li>
                        <li><b>/dev/cdrom</b>: Dispositivos cdrom.</li>
                    </ul>

                    <h5>Arquivos em /boot:</h5>
                    <ul>
                        <li><b>/boot/config-versao-modelo</b>: Configurações do kernel, opções e módulos compilados juntos ao mesmo;</li>
                        <li><b>/boot/initrd.img-versao-modelo</b>: Imagem de disco RAM inicial, que carrega sistema de arquivos temporário em memória, para inicialização do sistema;</li>
                        <li><b>/boot/System-map-versao-modelo</b>: Mapas dos dispositivos dos discos. Gerencia memória antes do carregamento do kernel;</li>
                        <li><b>/boot/vmlinuz-versao-modelo</b>: Arquivo com informações da memória virtual para uso ao kernel, ao mesmo compactado com extração automática;</li>
                        <li><b>/boot/grub</b>: Diretório de configuração do inicializador GRUB.</li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Usuários</h4>
                <div class="card-body">
                    <h5>Tipos:</h5>
                    <ul>
                        <li><b>Usuário comum/padrão/regular</b> ($): (UID/GID 1000 à 60000, alguns iniciam em 500) é o padrão para utilização do Linux, possui restrições de gerenciamento sensíveis ao sistema, shell padrão (bash) e diretório home (/home);</li>
                        <li><b>Usuário de sistema</b>: (UID/GID 1 à 99, ou entre 500-1000) é fictício, criado durante a instalação de algum script, para execução de processos, não possuindo capacidade de login no sistema. Geralmente não possui shell (/sbin/nologin), nem diretório home (caso possuir, geralmente não está vinculado a '/home');</li>
                        <li><b>Usuário de serviço</b>: (UID/GID 1000 à 60000 vinculado a conta de serviço) é fictício, similar ao de sistema (diferencia-se nos identificadores), criado para instalação e configuração de serviços no sistema;</li>
                        <li><b>Administrador</b> (root, #): (UID/GID 0), é o super user possui permissão total de gerenciamento do sistema. O root (<b>sudo</b>, super user do) é o único usuário com permissão de gerenciamento fora de seu diretório home, total ao sistema. Possui diretório home dedicado (/root).</li>
                    </ul>

                    <h5>Arquivos de usuário e grupo:</h5>
                    <p>Arquivo '/etc/passwd' possui informações dos usuários, separadas por ':'. Constituem, respectivamente, login do usuário, senha ('x', determinando que a senha está em '/etc/shadow', ou '*', determinando que o login está desabilitado, ou linha em branco ou '!', determinando ausência de senha), UID (user identification), GID (group identification), GComs (dados de comentários do usuário, separados por vírgula), localização home do usuário e shell do usuário. Arquivo '/etc/shadow' possui informações das senhas dos usuários. Constituem, respectivamente, login do usuário, senha criptografada, data da modificação de senha (nº de dias), nº de dias para Linux permitir nova modificação de senha, nº de dias que o usuário pode manter mesma senha, nº de dias para expirar senha, nº de dias após expiração de senha, nº de dias até expiração de senha e campo reservado para futura informação. '/etc/login.defs' é o arquivo padrão lido quando novo usuário é cadastrado no sistema. '/etc/skel' é o arquivo que contém informações que são copiadas para dentro de /home/novoUsuario quando novo usuário é cadastrado. Todo usuário possui grupo relacionado. Nativamente, quando usuário é criado, também é criado grupo com mesmo nome. '/etc/group' contém os grupos cadastrados no sistema, constituindo nomeGrupo:senhaGrupo:GID:usuario1,usuario2 (senha 'x' indica que está em '/etc/gshadow', arquivo que contém informações das senhas dos grupos no sistema). Assim como usuários, há também grupo de sistema, geralmente usados para execução de processos (flag '--system' indica cadastro de usuário ou grupo de sistema). '/etc/sudoers' controla quem pode usar comando <i>sudo</i> e como (diretório '/etc/sudoers.d' possui arquivos que suplementam configurações ao sudoers).</p>
<small><pre><code>
<u><b>Informações de usuários</b></u>:
<b>Username</b>: Nome do usuário
<b>Password Status</b>: P(senha utilizável), L(senha bloqueada), NP(não há senha)
<b>Change Date</b>: Data de última modificação de senha
<b>Minimum</b>: Nº mínimo de dias que deve passar para permitir alteração de senha
<b>Maximum</b>: Nª de dias restantes para senha expirar
<b>Warn</b>: Nº de dias, antes da expiração de senha, para notificar usuário
<b>Inactive</b>: Nº de dias, após expiração de senha, que usuário permanece ativo

<u><b>Comandos de usuários</b></u>:
<b>w</b>: Ver detalhes de usuários conectados
<b>whoami</b>: Ver usuário atual (ou 'who')
<b>quota</b>: Informações do usuário na sessão
<b>id nomeUsuario</b>: Verificar se usuário encontra-se no sistema
<b>getent passwd</b>: Abrir passwd
<b>Ver informações da senha de user</b>: chage -l nomeUsuario
<b>pwconv</b>: Criar arquivo '/etc/shadow' a partir de '/etc/passwd' <span class="text-muted">(pwunconv faz operação inversa)</span>
<b>sudo + comando</b>: Comando em modo administrador
<b>sudo su</b>: Set user, alternar usuário, padrão (nome omitido) é root
<b>sudo su -</b>: Alternar para usuário root, alternando todas definições do ambiente para root
<b>sudo su - nomeUsuario</b>: Alternar usuário, alternando todas definições do ambiente para novo usuário
<b>su - nomeUsuario</b>: Sair do usuário root, para usuário comum
<b>Alterar senha de usuário</b>: passwd [parâmetros] [utilizador] <spam class="text-muted">(passwd -S sysadmin)</spam>
<b>Alterar metadados de usuário</b>: chage -W 5 nomeUsuario (alterar nº dias de avisos antes de expirar senha)(em '/etc/shadow')
<b>Criar usuário</b>: adduser nomeUsuario ('/etc/adduser.conf'. Ou useradd, '/etc/default/useradd', useradd não atribui shell ao usuário)
<b>Criar usuário que não pode logar no shell</b>: adduser --shell /usr/sbin/nologin --home /usr/share/novoUser novoUser (ou '/bin/false'. Para users que usarão apenas arquivos compartilhados ou executar processo)
<b>Listar usuários</b>: cat /etc/passwd
<b>Deletar usuário</b>: deluser nomeUsuario (ou userdel)

<u>Grupos</u>:
<b>Adicionar grupo</b>: groupadd nomeGrupo (ou 'addgourp nomeGrupo')
<b>Adicionar grupo de sistema</b>: groupadd --system nomeGrupo
<b>Adicionar usuário em grupo</b>: gpasswd -a nomeUsuario nomeGrupo
<b>Adicionar usuário logado em grupo suplementar</b> (temporariamente): newgrp nomeGrupo
<b>Manipular informações de usuários e grupos</b>: usermod e groupmod
<b>Adicionar usuário em grupo</b>: usermod -aG nomeGrupo nomeUsuario (-a é append)
<b>Renomear grupo</b>: groupmod -n novoNomeGrupo antigoNomeGrupo
<b>Definir senha para grupo</b>: gpasswd nomeGrupo
<b>Deletar grupo</b>: delgroup nomeGrupo (ou groupdel)
<b>Listar grupos</b>: groups (ou 'groups nomeUsuario' para grupos do usuário)

<u>Exemplos</u>:
useradd -s /bin/bash -m -c "UB Social, 10, 519999999, 5198989898," ubsocial
'-s' define shell
'-m' define home
'-c' define campos de comentários (gecos)

chage -W 5 nomeUsuario
'-m' nº mínimo de dias entre troca de senhas
'-M' nº máximo de dias entre troca de senhas
'-E' data expiração de senha
'-e' forçar expiração de senha (passwd -e nomeUsuario)

<u>Exemplo, configuração de usuários em servidor</u>:
- Cadastrar grupos:
addgroup empresa
addgroup tecnologia
addgroup rh
addgroup comercial
addgroup financeiro
- Adicionar grupo ao diretório: chgrp empresa dir1/ (<span class="text-muted">Somente usuários do grupo 'empresa' poderão acessar diretório 'dir1/'</span>)
</small></pre></code>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Rede</h4>
                <div class="card-body">
                    <h5>Tipos de internet protocol:</h5>
                    <ul>
                        <li>IPv4:
                            <ul>
                                <li>IPs públicos (válidos na internet) e privados (inválidos na internet) diferentes;</li>
                                <li>Possui Nat e classes de rede;</li>
                                <li>Localhost: 127.0.0.1</li>
                            </ul>
                        </li>
                        <li>IPv6:
                            <ul>
                                <li>IPs públicos e privados iguais;</li>
                                <li>Não possui Nat e classes de rede;</li>
                                <li>Localhost: ::1</li>
                            </ul>
                        </li>
                    </ul>

                    <h5>Arquivos:</h5>
                    <ul>
                        <li>'<i>/etc/hostname</i>' armazena o nome do dispositivo ($HOSTNAME);
                            <ul>
                                <li>Modificar hostname: <span class="text-muted">hostnamectl --set-hostname novoNome</span></li>
                                <li>Modificar hostname temporariamente: <span class="text-muted">hostname novoNome</span></li>
                            </ul>
                        </li>
                        <li>'<i>/etc/network/interfaces</i>' arquivo de configuração de IPs (Debian);
                            <ul>
                                <li>'auto' significa que placa será configurada automaticamente na inicialização do serviço;</li>
                                <li>'allow-hotplug' significa que placa será iniciada automaticamente no boot do dispositivo, mas dependerá de 'ifup' quando o serviço de rede for iniciado;</li>
                                <li>iface nomePlaca inet metodoAtribuicao
                                    <ul>
                                        <li>IP dinâmico: iface nomePlaca inet dhcp</li>
                                        <li>IP fixo:
<small><pre><code>
iface nomePlaca inet static
address 192.168.0.20/24
netmask 255.255.255.0
gateway 192.168.0.1

<b>Ex: Incluir placa virtual de rede em '/etc/network/interfaces'</b>
auto nomePlaca:0
iafce nomePlaca:0 inet static
address 10.11..12.13
netmask 255.255.255.0
(<span class="text-muted">Sair do arquivo, reiniciar service (sudo systemctl restart networking) e verificar com 'ip a'</span>)
</code></pre></small>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>'<i>/etc/sysconfig/network-scripts/ifcfg-interfaceRede</i>' arquivo de configuração de IPs (Red Hat);</li>
                        <li>'<i>/etc/hosts</i>' possui tabela de hosts do dispositivo, seguindo sintaxe 'ip nomeHost.dominio nomeHost'. Esse arquivo é lido antes de acessos ao DNS;</li>
                        <li>'<i>/etc/resolv.conf</i>'realiza configuração de servidores de DNS para cliente Linux. Possui sintaxe:</li>
<small><pre><code>
search nomeHost.dominio
domain nomeHost.dominio
nameserver dnsPrimario
nameserver dnsSecundario
</code></pre></small>
                    </ul>
                    
                    <h5>Componentes:</h5>
                    <ul>
                        <li><b>eth</b> (eth0, eth1, eth2...): Ethernet, placa de rede cabeada do dispositivo;</li>
                        <li><b>wlo</b> (wlo0, wlo1, wlo2...), <b>wlan</b> (wlan0, wlan1, wlan2...): Wlo é wireless network interface (NIC). Wireless-LAN (Local Area Network), plca de wifi do dispositivo;</li>
                        <li><b>ra</b> (ra0, ra1, ra2...): Placa de rede com chipset Ralink;</li>
                        <li><b>lo</b>: Loopback, interface de rede virtual do dispositivo para conexões TCP/IP.</li>
                    </ul>

                    <h5>Comandos:</h5>
                    <p>Entre os comandos de rede, tem-se <b>route</b> (<span class="text-muted">route -n</span>) para visualizar e manipular tabela de roteamento IP (inet) e gateway. O <b>ifconfig</b> e <b>iwconfig</b> para informações dos componentes de rede do dispositivo, <b>ip a</b> (ou 'ip address show'), <b>ip r</b> (ou 'ip route show' ver tabela de rotas) e <b>nmcli</b> são similares a ambos. <b>ip addr show</b> mostra IP do dispositivo. <b>iwlist scann</b> mostra todas redes sem fio. <b>netstat</b> ou <b>ss</b> mostra todas conexões de entrada e saída de rede, tabelas de roteamento e estatísticas do protocolo de rede. '<i>netstat -atunp</i>' mostra com detalhes de PID, TCP e UDP. <b>ping</b> mostra tempo de envio/recebimento de resposta em rede (Ex: '<span class="text-muted">ping -c 4 192.168.1.2</span>' (Ping para esse IPv4 limitado em 4 iterações). Ex2: '<span class="text-muted">ping uol.com.br</span>' (Ping no site do uol)). <b>host</b> (<i>host -opcao idHost</i>, Ex: '<span class="text-muted">host www.google.com</span>') localiza informações de rede como, por exemplo, IPv4 (opção -4) ou IPv6 (opção -6) de determinado host (comando <b>dig</b> informa com mais detalhes). As portas de rede encontram-se em '/etc/services'. Entre os firewalls Linux, tem-se <b>iptables</b>, juntamente com <b>UFW</b> (Ubuntu firewall), que possui o GUFW como serviço GUI para gerenciamento. MacAddress é o id da placa física, geralmente identificado como link/ether, HWaddr ou HW, seguindo padrão 'xx:xx:xx:xx:xx:xx' (Ex: <span class="text-muted">5c:cd:5b:74:ae:32</span>). O MacAddress da placa wifi do dispositivo geralmente encontra-se em wlan, identificado como 'HWaddr' ou 'ether'. Também pode ser encontrado com <b>inxi -Nn</b> na opção state 'up'. cURL (<b>curl</b>) oferece interface CLI para transferência de dados via protocolos de rede. <b>wget</b> é similar ao curl (Ex: '<span class="text-muted">wget http://ftp.gnu.org/pacote.tar.gz</span>'). <b>traceroute</b> mostra rota via rede até o destino (Ex: '<span class="text-muted">traceroute www.google.com</span>'). Comando <b>ssh</b> (secure shell) faz comunicação entre dispositivos via rede, com porta padrão 22. Por padrão no Debian, somente usuário comum pode conectar-se via SSH. Passo a passo para acessar VM via SSH:</p>
                    <ol>
                        <u>Host</u>:
                        <li>Instalar SSH server: <span class="text-muted">sudo apt install openssh-server</span></li>
                        <li>Iniciar SSH: <span class="text-muted">systemctl start ssh</span> (status para verificar)</li>
                        <li>Verificar se porta 22 está aberta: <span class="text-muted">ss -atun | grep 22</span></li>
                        <u>VM</u>:
                        <li>Alterar configuração de rede da VM para modo Bridge
                            <ul>
                                <li>Selecionar modo Bridge</li>
                                <li>Selecionar placa de rede da máquina física que está conectada à internet (wireless é wlan, cabeada é eth)</li>
                            </ul>
                        </li>
                        <li>Instalar SSH client: <span class="text-muted">sudo apt install openssh-client</span></li>
                        <li>Reiniciar rede:
                            <ol>
                                <li><span class="text-muted">systemctl restart networking</span></li>
                                <li><span class="text-muted">ifdown nomePlacaFisica</span></li>
                                <li><span class="text-muted">ifup nomePlacaFisica</span></li>
                                <li><span class="text-muted">dhclient -v</span></li>
                            </ol>
                        </li>
                        <u>Host</u>:
                        <li>Conectar: <span class="text-muted">ssh -l nomeUsuarioVM ipVM</span></li>
                        <li>Informar 'yes' para aceitar key do server</li>
                    </ol>
                    <u>Permitir SSH via root</u>:
                    <ol>
                        <li>Na VM, abrir arquivo de configuração: <span class="text-muted">nano /etc/ssh/sshd_config</span></li>
                        <li>Nesse arquivo, descomentando a linha desejada, pode-se alterar as configurações ssh</li>
                        <li>Modificar linha PermitRootLogin para 'PermitRootLogin yes'</li>
                        <li>Reiniciar rede: <span class="text-muted">systemctl restart networking</span></li>
                        <li>Conectar: <span class="text-muted">ssh -l root ipVM</span></li>
                        <li>Se alterou porta: <span class="text-muted">ssh -l root piVM -p numPorta</span></li>
                    </ol>
                    <p>No caso acima, rede tipo <i>NAT</i> (Network address translation) é quando placa de rede da VM usa rede (IP) da máquina física para conexão. O tipo <i>Bridge</i> (Ponte) é quando VM conectada com cabo diretamente no modem, usando placa da máquina física somente como ponte para conexão.</p>
<small><pre><code>
SSH (secure shell):
<i>ssh -p numPorta usernameRemoto@ipRemoto</i> (-4 para somente IPv4, -6 para somente IPv6)
<b>Conexão SSH</b>: ssh -p 22 root@10.1.2.3 (porta 22(padrão), username 'root', ip '10.1.2.3')

Comando 'ss' (sockets services - alternativo ao netstat):
ss -atun | grep 22
-a: all
-t: tcp
-u: udp
-n: mostrar em formato numérico
LISTEN: SSH ouvindo na porta 22 (disponível)
</code></pre></small>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Terminais</h4>
                <div class="card-body">
                    <p>Emulador de terminal é o programa que emula um terminal, no Linux representado pelo shell. Terminais virtuais (<b>tty</b>, teletypes) suportam o ambiente do sistema. Para acessar a tty utiliza-se 'ctrl+alt+FnumTty' (Ex: '<span class="text-muted">ctrl+alt+F2</span>' acessará tty2), para alternar a tty utiliza-se 'alt+FnumTty'. Algumas tty's carregam GUI (geralmente tty1 e tty2), outras somente CLI (geralmente tty3 a 6).</p>

                    <h5>Sessões:</h5>
                    <p>Linux funciona sob sessão(ões) ativa(s). O login criará 1 sessão, composta por dados gerados do mesmo. Todo o log no sistema pertencerá a sessão ativa. Um mesmo usuário pode criar várias sessões ao mesmo tempo (cada shell executado e não fechado criará nova sessão, SHLVL mostra o nível do shell). Toda vez que usuário comum executar '<span class="text-muted">sudo su</span>', criará nova sessão com root, e poderá encerrá-la com '<span class="text-muted">exit</span>', '<span class="text-muted">ctrl+d</span>' ou '<span class="text-muted">logout</span>' para retomar a sessão com usuário comum.</p>

                    <h5>Shell:</h5>
                    <p>Camada de acesso básico ao Linux, utilizada para execução de binários e super binários. Para executar shell, basta informar seu nome ou diretório (Ex: '<span class="text-muted">/usr/bin/sh</span>'). Comandos para encerrá-lo são os mesmos de sessão acima. Arquivo '/etc/bash.bashrc' possui informações dos shells interativos. Entre os tipos de shell, tem-se:</p>
                    <ul>
                        <li>sh (Bourne shell)</li>
                        <li>bash (Bourne again shell, evolução do sh)</li>
                        <li>csh (C shell)</li>
                        <li>tcsh (Turbo C shell, evolução do csh)</li>
                        <li>ksh (Korn shell)</li>
                        <li>zsh (Z shell)</li>
                    </ul>

                    <h5>Variáveis:</h5>
                    <p>Espaços de memória que armazenam valores, com função de fornecer dados ao sistema. Comando <b>echo</b> faz chamada de conteúdo no shell em stdout (Ex: '<span class="text-muted">echo "ola"</span>' mostrará "ola" na tela). Para listar todas variáveis, tem-se 'set' (locais), 'env' (globais) e 'printenv'. Arquivo '/etc/sysctl.conf' realiza definições de variáveis de sistema para o kernel.</p>
                    <ul>
                        <li><b>Variáveis locais</b>: Disponíveis somente para shell atual, são voláteis, possuindo visibilidade restrita ao ambiente onde foi definida. Sintaxe: <span class="text-danger">nome=valor</span>;</li>
                        <li><b>Variáveis globais</b> (de ambiente, environment): Não possuem restrição de ambiente, disponíveis a todo sistema. Comando 'export NOMEVARIAVEL', torna variável local em global. Sintaxe: <span class="text-danger">export NOME=valor</span>.</li>
                    </ul>
                    <ul>
                        <u>Variáveis globais</u>:
                        <li>HOME: Identifica o diretório do usuário;</li>
                        <li>HOSTTYPE: Identifica a plataforma do dispositivo;</li>
                        <li>HISTSIZE: Armazena limite de comando armazenados em histórico (histfile, padrão é 1000);</li>
                        <li>HISTFILE: Identifica local onde histórico de comandos é armazenado;</li>
                        <li>HISTFILESIZE: Armazena limite de linhas que o histórico (histfile) pode possuir (padrão é 2000);</li>
                        <li>SHELL: Identifica o shell atual;</li>
                        <li>TERM: Identifica o terminal atual;</li>
                        <li>USER: Identifica o usuário atual;</li>
                        <li>PATH: Identifica lista de diretórios dos binários executáveis shell (separados por ':');</li>
                        <li>PS1: Representa as informações exibidas no prompt (linha do shell para comando (prompt string), como '<span class="text-muted">usuario@nomeMaquina:~$</span>');</li>
                        <li>LOGNAME: Identifica nome do usuário logado atual;</li>
                        <li>OSTYPE: Identifica SO atual.</li>
                    </ul>
<small><pre><code>
<b>Exemplo</b>:
nome="ubsocial"
echo $nome <span class="text-muted">(toda vez que nome for chamada, representará seu valor: <i>ubsocial</i>)</span>
unset nome <span class="text-muted">(descarta variável)</span>
echo $HOME <span class="text-muted">(exibirá valor de HOME)</span>
</small></pre></code>

                    <h5>Alias:</h5>
                    <p>Apelido/atalho atrelado a determinada rotina. Comando 'alias' listará todos aliases do sistema.</p>
<small><pre><code>
<b>Exemplo</b>:
alias j="ls -l"
j <span class="text-muted">(ao digitar 'j' será executado seu valor: Comando 'ls -l')</span>
unalias j <span class="text-muted">(descarta alias)</span>
</code></pre></small>

                    <h5>Arquivos de variáveis:</h5>
                    <p>Para armazenar variável no Linux, precisa salvá-la no arquivo, caso contrário ela é removida da memória após finalizar sessão.</p>
                    <ol>
                        <u>Escopo global</u> (/etc):
                        <li><i>/etc/profile</i>: Armazena comandos e variáveis para usuários do sistema;</li>
                        <li><i>/etc/environment</i>: Usado para definir variáveis globais;</li>
                        <u>Escopo local</u> (/home):
                        <li><i>/home/.bashrc</i>: Script de inicialização do bash para shells sem login;</li>
                        <li><i>/home/.profile</i> ou <i>/home/._profile</i>: Script de inicialização do bash para shells com login;</li>
                        <li><i>/home/.bash_login</i> e <i>/home/.bash_logout</i>: Possui binários que são executados no login/logout do shell.</li>
                        Comando 'source' reseta o arquivo (Ex: '<span class="text-muted">source /etc/profile</span>').
                    </ol>

                    <h5>Arquivos de exibição de mensagens:</h5>
                    <ul>
                        Responsáveis por armazenar mensagens padrão stderr.
                        <li><i>/etc/issue</i>: Mensagens antes do login do sistema;</li>
                        <li><i>/etc/motd</i>: Mensagens após login do sistema;</li>
                        <li><i>/etc/issue.net</i>: Mensagens via rede, logins remotos;</li>
                        <li><i>~/.bash_history</i>: Histórico dos comandos.</li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Shell</h4>
                <div class="card-body">
                    <p>Camada de comunicação entre binários e kernel. As sintaxes do resumo possuem '&lt;&gt;' para termo que deve ser informado obrigatoriamente, e '[]' para termo que pode ser informado opcionalmente. Nessas sintaxes, todo termo fora de símbolos (parênteses, colchetes, chaves) deve ser informado obrigatoriamente. Comando binário interpretado pelo shell possui composição:</p>
                    <ol>
                        <li><b>comando</b>: Arquivo binário em '/usr/bin';</li>
                        <li><b>parâmetro(s)</b>: Opcional, altera comportamento do comando. Também chamado de 'flag' e 'opção'. Representado por 1 hífen seguido de letra (forma simplificada, padrão POSIX), ou 2 hífens seguidos de palava (forma extensa, arquitetura GNU e UNIX). Na forma simplificada, pode-se conter vários parâmetros aninhados, onde tem-se 1 hífen seguido das letras dos respectivos parâmetros;</li>
                        <li><b>argumento(s)</b>: Opcional, especifica alvo do comando. Representado por palavra(s) ou expressão(ões).</li>
                        <i class="text-muted">Resumidamente, parâmetro modifica execução do comando para determinado argumento.</i>
                    </ol>
                    <p>Sintaxe 1: <span class="text-danger">comando [-p] [argumento]</span><br>Sintaxe 2: <span class="text-danger">comando [--parametro] [argumento]</span></p>
                    
                    <u>Exemplos</u>:
                    <p><span class="text-muted">ls</span><br><span class="text-muted">ls /home</span><br><span class="text-muted">ls -s /home</span><br><span class="text-muted">ls -s -a /home</span><br><span class="text-muted">ls -sa /home</span><br><span class="text-muted">ls --size /home</span><br><span class="text-muted">ls --size --all /home</span></p>

                    <h5>Atalhos shell</h5>
                    <ul>
                        <li><b>tab</b>: Autocompletar comando;</li>
                        <li><b>seta up</b>: Comando anterior;</li>
                        <li><b>seta down</b>: Mostrar comando sucessor ao anterior;</li>
                        <li><b>^c</b>: Quer dizer <i>ctrl+c</i>;</li>
                        <li><b>M-c</b>: Quer dizer <i>alt+c</i>;</li>
                        <li><b>ctrl+shift+c</b>: Copiar;</li>
                        <li><b>ctrl+shift+v</b>: Colar;</li>
                        <li><b>shift+pgup</b>: Scroll acima;</li>
                        <li><b>shift+pgdn</b>: Scroll abaixo;</li>
                        <li><b>ctrl+a</b>: Mover cursor ao começo da linha;</li>
                        <li><b>ctrl+e</b>: Mover cursor ao final da linha;</li>
                        <li><b>ctrl+u</b>: Recortar tudo à esquerda do cursor;</li>
                        <li><b>ctrl+k</b>: Recortar tudo à direita do cursor;</li>
                        <li><b>ctrl+y</b>: Colar conteúdo recortado;</li>
                        <li><b>alt+b</b>: Voltar 1 palavra;</li>
                        <li><b>ctrl+w</b>: Deletar 1 palavra;</li>
                        <li><b>ctrl+p</b>: Comando anterior;</li>
                        <li><b>ctrl+n</b>: Próximo comando;</li>
                        <li><b>ctrl+c</b>: Abrir nova linha a partir do cursor (cancelar operação em andamento);</li>
                        <li><b>ctrl+d</b>: Sair;</li>
                        <li><b>ctrl+z</b>: Pausar comando em andamento;</li>
                        <li><b>alt+f</b>: Mover 1 palavra;</li>
                        <li><b>alt+d</b>: Deletar 1 palavra;</li>
                        <li><b>ctrl+r</b>: Iniciar/Próxima pesquisa;</li>
                        <li><b>ctrl+g</b>: Cancelar pesquisa;</li>
                        <li><b>ctrl+x</b> ou <b>+e</b>: Editar;</li>
                        <li><b>ctrl+l</b>: Limpar shell (move cursor para baixo até ocultar conteúdo anterior);</li>
                        <li><b>ctrl+-</b>: Desfazer;</li>
                        <li><b>!!</b>: Repetir último comando.</li>
                    </ul>

                    <h5>Comandos gerais:</h5>
<small><pre><code>
<b>Ver shell padrão</b>: echo $SHELL (ou 'echo $0')
<b>Data e hora do sistema</b>: date
<b>Fechar o bash</b>: exit
<b>Limpar bash</b>: clear
<b>Ajuda no bash</b>: help
<b>Comentário no Bash</b>: #comentario (Comentários não afetam execuções no shell)
<b>Concatenar comandos</b> (; ou &&): ls ; echo "a" (ou ls && echo "a")

<b>Histórico de comandos</b>: history
<b>Histórico dos 10 últimos comandos</b>: history 10 (ou fc -l 10)
<b>Histórico dos comandos 2 ao 6</b>: fc -l 2 6
<b>Histórico dos comandos na última hora</b>: fc -l h
<b>Executar 34º comando do histórico</b>: !34

<b>Ver informações de hardware</b>: lshw
<b>Ver informações sobre processador</b>: lscpu (mesmo que '/proc/cpuinfo')
<b>Ver informações da distro</b> (necessário instalar): neofetch
<b>Ver versão da distro</b>: lsb_release -a (ou cat /etc/*-release)
<b>Ver versão do kernel</b>: uname -r
<b>Ver detalhes do kernel</b>: uname -a
<b>Ver informações de memória cache em tempo real</b>: sudo slabtop (ctrl+c para sair)
<b>Ver informações de tempos em tempos</b>: watch –n 5 date (mostrará date a cada 5seg)
<b>Ver nome do dispositivo</b>: hostname ('-i' mostrará ip)
<b>Ver arquitetura do dispositivo</b>: arch
<b>Ver particionamento do disco</b>: lsblk (dispositivos de bloco disponíveis)
<b>Ver espaços das partições</b>: df (-i para mostrar inodes, buracos de memória no hardware de cada partição)
<b>Ver informações sobre uso do disco</b>: du (du -sh *)
<b>Ver mensagens do sistema</b>: sudo dmesg (mesmo que '/var/log/dmesg')
<b>Ver quantidade de memória livre</b>: free ('-m' para valores em Megabytes, '-h' para valores organizados. Comando analisa '/proc/meminfo')
<b>Verificar e reparar sistema de arquivos</b>: fsck (ou 'fsck nomeDisco'. Comando 'mkfs' é similar. 'mkswap' para disco swap)
<b>Gerenciar partições do dispositivo</b>: fdisk ('-l' listará, Ex: 'fdisk -l /dev/sda')
<b>Ver módulos kernel carregados em memória</b>: lsmod
<b>Ver arquivos abertos</b>: lsof
<b>Ver dispositivos pci</b>: lspci
<b>Ver dispositivos scsi</b>: lsscsi
<b>Ver dispositivos usb</b>: lsusb
<b>Ver se comando é interno/externo</b>: type comando ('type ls', comando interno é 'shell builtin')
<b>Subshell (comando dentro de comando)</b>: ls $(which docker)
<b>Gravar shell</b>: script arquivoGravacao (Todos comandos/saídas no shell serão gravados no arquivoGravacao até ser informado 'exit' no shell)

<b>Desligar</b>: shutdown now (ou poweroff, ou init 0, ou shutdown 0)
<b>Logout</b>: logout
<b>Reiniciar</b>: reboot (ou shutdown -r, ou init 6)
</code></pre></small>

                    <h5>Create:</h5>
<small><pre><code>
<b>Criar diretório</b> (make directory): mkdir diretorio1 diretorio2 diretorio3
<b>Criar diretório com subdiretório</b>: mkdir -p diretorio1/diretorio2/diretorio\ 3/ ('\' não interpreta próximo caractere como comando ("diretorio 3"). '-p' não sobrescreve, caso diretório já exista)
<b>Criar arquivo</b>: touch nomearquivo (ou 'touch arquivo\ de\ teste' para criar "arquivo de teste")
</code></pre></small>

                    <h5>Remove:</h5>
<small><pre><code>
<b>Remover arquivo</b>: rm arquivo
<b>Remover diretório vazio</b>: rmdir diretorio
<b>Remover diretório não vazio</b> (recursive): rm -r diretorio (-f para remoção forçada)
<b>Remover sob confirmação</b> (interactive): rm -i arquivo
</code></pre></small>

                    <h5>List:</h5>
<small><pre><code>
<b>Listar conteúdo do diretório atual</b>: ls
<b>Listar conteúdo em diretório específico</b>: ls nomeDiretorio
<b>Listar diretório e subdiretórios</b>: ls -R (recursivamente)
<b>Listagem com detalhes</b>: ls -l
<b>Listagem com informações aprimoradas de armazenamento</b>: ls -l -h
<b>Listagem incluindo arquivos ocultos</b>: ls -a
<b>Listar diretório e subdiretórios, recursivamente</b>: ls -lR
<b>Listagem com informações de armazenamento, arquivos ocultos e subdiretórios</b>: ls -Rlah
<b>Ver diretórios árvore FHS</b>: tree ('tree -L 1 /' nível 1, somente 1 diretório. 2 para diretório e subdiretórios)
<b>Ver metadados de arquivo</b>: stat nomeArquivo
<b>Ver formato de arquivo</b>: file nomeArquivo
<b>Ver conteúdo de arquivo</b>: cat nomeArquivo ('tac' mostra inversamente)
<b>Ver contagens de arquivo</b>: wc nomeArquivo (nº de linhas, palavra e bytes, respectivamente)
<b>Ver início de conteúdo de arquivo</b>: head nomeArquivo ('tail' mostra o final)
<b>Ver conteúdo de arquivo, com paginação</b>: less /etc/services (Less: 'n' pula pra próxima página, '/termo' procura por termo específico, 'more' é o inverso de less)
<b>Inserir conteúdo de arquivo em outro arquivo</b>: cat arquivo &gt; arquivoGravacao
<b>Inserir conteúdo de arquivo no final de outro arquivo</b>: cat arquivo &gt;&gt; arquivoGravacao

<b>Conteúdo do 'ls -l'</b>:
<span class="text-danger">[tipoArquivo] [permissões(proprietário/grupo/outros)] [contagem linksFisicos] [proprietárioDoUsuario] [proprietárioDoGrupo] [tamanhoArquivoBouKB] [dthrRegistro] [nomeArquivo.extensao]</span>
Exemplo (arquivo): <span class="text-muted">-rw-r--r-- 1 root root 18047 Dec 20 2021 alternatives.log</span>
Exemplo (diretório): <span class="text-muted">drwxr-x--- 2 root adm 4096 Dec 20 2021 apache2</span>

<b>d</b>: Diretório
<b>-</b>: Arquivo regular (Indica que é arquivo, não sendo diretório)
<b>l</b>: Link simbólico (Aponta para outro arquivo, 'soft link'. Links físicos, não simbólicos, são entrada adicional no sistema de arquivos que aponta para mesmo local (inode) do disco. Comando 'ls -i' mostra inodes)
<b>s</b>: Arquivo é um socket (Comunicação entre processos)
<b>p</b>: Arquivo é um fifo, named pipe (Comunicação entre processos. Fifo- FistIn FirstOut, muito usado para filas de elementos em lista de espera)
<b>b</b>: Arquivo é dispositivo de bloco (Comunicação com hardware, com buffer: região temporária de memória para escrita/leitura)
<b>c</b>: Arquivo é dispositivo de caractere (Comunicação com hardware, sem buffer)
<b>u</b>: O mesmo que <i>c</i>
</code></pre></small>

                    <h5>Print:</h5>
<small><pre><code>
<b>Impressão simples</b>: lp arquivo.txt
<b>Impressão avançada</b>: lp -d nomeOuIdImpressora -n 2 -P 1,3 Documents/arquivo (2 cópias, páginas 1 e 3)
<b>Detalhes da impressora</b>: lpstat -p -d
<b>Ver fila de impressão</b>: lpq
</code></pre></small>

                    <h5>Change directory:</h5>
<small><pre><code>
<b>Entrar em outro diretório</b>: cd nomeDiretorio (Exemplo: 'cd /home/usuario/Documents')
<b>Voltar 1 diretório (diretório pai)</b>: cd ..
<b>Voltar 2 diretórios</b>: cd ../../ (e assim por diante)
<b>Entrar no diretório do usuário</b>: cd (ou cd ~)
<b>Entrar no diretório root</b>: cd /
<b>Criar link simbólico</b>: ln -s arqOrigem /home/arqLinkSimbolico (ou somente 'ln' para criar link físico)
<b>Listar links simbólicos</b>: ln -lh
</code></pre></small>

                    <h5>Copy e move:</h5>
<small><pre><code>
<b>Copiar e colar arquivo</b>: cp arquivo diretorioDestino
<b>Copiar e colar recursivamente</b>: cp -r dirOrigem dirDestino (-p mantém metadados, 'preserve')
<b>Copiar e colar, renomeando</b>: cp arquivo dirDestino/novoNomeArquivo
<b>Mover</b>: mv arquivo diretorioDestino (o mesmo vale para diretórios)
<b>Renomear</b>: mv arquivoAtual arquivoNovo (o mesmo vale para diretórios)
<b>Comparar arquivos</b>: diff arquivo1 arquivo2 ('-r' recursivo, '-i' ignora CamelCase, '-a' compara qualquer tipo de arquivo. 'cmp' é comando similar)
<b>Sincronizar arquivos</b>: rsync arqOriginal arqDuplicado ('-r' recursivo, '-v' verbose, '-a' mantém todos metadados)

<b>Copiar e colar</b> (bit a bit): dd if=/dev/arquivo1 of=/tmp/arquivo2 bs=1M count=50
if: arquivo de entrada, a ser lido
of: arquivo de saída, a ser gravado
bs: tamanho do bloco (Kilobyte, Megabyte, Gigabyte, Terabyte, etc.)
count: contagem de blocos a serem lidos da entrada
</code></pre></small>

                    <h5>Regular expressions:</h5>
                    <p>Também conhecidos por globbing (file globbing), são caracteres regex utilizados em conjunto.</p>
<small><pre><code>
<u><b>Metacaracteres</b> (representação)</u>:
<b>.</b> Qualquer caractere único
<b>*</b> Conjunto de caracteres
<b>?</b> Apenas 1 caractere
<b>[ ]</b> Intervalo de caracteres
<b>[a-z][0-9]</b> Caracteres de 'a' até 'z', caracteres de '0' até '9'
<b>[a,z][0,9]</b> Caracteres 'a' e 'z', caracteres '0' e '9'
<b>[a-z,1,0]</b> Caracteres de 'a' até 'z' ou '1' ou '0'
<b>[^ ]</b> Faixa de caracteres ausentes
<b>{ }</b> Padrões de caracteres
<b>x{ab,01}</b> Caracteres 'xab' ou 'x01'
<b>x{a-c,f}</b> Caracteres 'xa', 'xb', 'xc' ou 'xf'
<b>^</b> Se o 1º caractere do padrão, o padrão deve estar no início da linha
<b>$</b> Se o último caractere do padrão, o padrão deve estar no final da linha
<b>+</b> 1 ou mais do padrão anterior
<b>|</b> Alternativa ao <b>-</b> um 'ou' lógico
<b>( )</b> Agrupamento
<b>!</b> Excluir caractere da operação
<b>\b</b> Borda de uma palavra
<b>\n</b> Recuperar n agrupamento (n é um nº)
<b>\</b> Acessar caracteres especiais e metacaracteres (também considerado caractere de escape)

<u><b>Classificação</b></u>:
<b>Marcação</b> (âncoras): ^ $ \b
<b>Quantificadores</b>: . ? * + {n[,m]} [...] [^...]
<b>Agrupamento</b>: () \n
<b>Outros</b>: \

<u><b>Exemplos</b></u>:
<b>Criar arquivos</b>: touch arq{1-3}.txt (gerará 'arq1.txt', 'arq2.txt' e 'arq3.txt')
<b>Listar tudo que começa com 'x'</b>: ls /etc/x*
<b>Listar tudo que tem 'x' no meio</b>: ls /etc/*x*
<b>Listar tudo que termina com '.conf'</b>: ls /etc/*.conf
<b>Listar tudo que termina com, ou 'tab' ou 'swd'</b>: ls /etc/*{tab,swd}
<b>Listar tudo que tem 2º caractere 'a', 3º 's', e depois qualquer coisa</b>: ls /etc/?as*
<b>Listar tudo que tem 'a' na 4ª posição, depois qualquer coisa</b>: ls /etc/???a*
<b>Listar tudo que começa com 'f', seguido de caractere na faixa entre 'a' e 'i', depois qualquer coisa</b>: ls /etc/f[a-i]*
<b>Listar tudo que começa com 'f', seguido de caractere 'a' ou 'c', depois qualquer coisa</b>: ls /etc/f[a,c]*
<b>Listar tudo que começa com 'f', seguido de caractere entre 'a' até c, ou 'e', depois qualquer coisa</b>: ls /etc/f[a-c,e]*
<b>Listar tudo que tenha no meio caracteres de 'a' até 'c', depois qualquer coisa</b>: ls /etc/*[a-c]*
<b>Listar tudo que, por 2º, listar ou 'am' ou 'ul', depois qualquer coisa</b>: ls /etc/?{am,ul}*
<b>Listar tudo que, por 2º, listar sequência do 'a' até 'm' ou do 'u' até 'l', depois qualquer coisa</b>: ls /etc/?[am,ul]*
<b>Procurar em 'arquivo.txt' termos que terminam com 'teste'</b>: grep '$teste' arquivo.txt (-i ignora case sensitive, -r recursivo)
<b>Codificar arquivo</b>: gpg -c arq1 ('gpg arq1.gpg' para decodificar)
</code></pre></small>

                    <h5>Permissões:</h5>
                    <p>No Linux, nenhum arquivo externo tem permissão de execução nativamente. Precisa-se aplicá-la com comandos <b>chown</b>, <b>chgrp</b>, <b>chmod</b> e <b>chattr</b>:</p>
                    <p>Change owner: <span class="text-danger">chown &lt;parâmetros&gt; &lt;novoDono&gt;[:novoGrupo] &lt;arquivo(s)&gt;</span><br>Change group: <span class="text-danger">chgrp &lt;parâmetros&gt; &lt;novoGrupo&gt; &lt;arquivo(s)&gt;</span><br>Change mode: <span class="text-danger">chmod &lt;[conjunto][ação][permissões]&gt;[,[conjunto][ação][permissões]] [parâmetros] &lt;arquivo(s)&gt;</span><br>Change attribute: <span class="text-danger">chattr &lt;[ação][parâmetros]&gt; &lt;arquivo(s)&gt;</span></p>
                    Ordenamento (ls -l):
                    <ol>
                        <span class="text-muted">-rw-r--r-- 1 sysadmin sysadmin 647 Dec 20 2017 hello.sh</span>
                        <li>(-): Indica arquivo;</li>
                        <li>(rw-) <b>Proprietário</b>, no caso o primeiro sysadmin;</li>
                        <li>(r--) <b>Grupo</b>, no caso o segundo sysadmin;</li>
                        <li>(r--) <b>Outros</b>, no caso outros usuários não proprietários do arquivo;</li>
                        <li>(1) Quantidade de subdiretórios;</li>
                        <li>(647) Tamanho do diretório;</li>
                        <li>(Dec 20 2017) Data de criação/modificação;</li>
                        <li>(hello.sh) Nome do arquivo/diretório.</li>
                    </ol>
                    Conjunto:
                    <ul>
                        <li>(<b>u</b>) Usuário proprietário do arquivo;</li>
                        <li>(<b>g</b>) Grupo proprietário do arquivo;</li>
                        <li>(<b>o</b>) Outros (qualquer usuário que não seja o proprietário do usuário ou membro do proprietário do grupo);</li>
                        <li>(<b>a</b>) Todos (refere-se ao usuário, grupo e outros)</li>
                    </ul>
                    Classificação:
                    <ul>
                        <li>Simbólico (literal): Alterar conjunto de permissões de cada vez, respectivamente 'rwx';
                            <ul>
                                <li>(<b>r</b>): Read (leitura);</li>
                                <li>(<b>w</b>): Write (escrita);</li>
                                <li>(<b>x</b>): Execution (execução);</li>
                                <li>(<b>-</b>): Não possui permissão.</li>
                            </ul>
                        </li>
                        <li>Octal (numérico): Alterar todos conjuntos de permissões (usuário, grupo e outros).
                            <ul>
                                <li>(<b>0</b>) Nenhuma permissão (-);</li>
                                <li>(<b>1</b>) Execução (x);</li>
                                <li>(<b>2</b>) Escrita (w);</li>
                                <li>(<b>3</b>) Escrita e execução (wx);</li>
                                <li>(<b>4</b>) Leitura (r);</li>
                                <li>(<b>5</b>) Leitura e execução (rx);</li>
                                <li>(<b>6</b>) Leitura e escrita (rw);</li>
                                <li>(<b>7</b>) Leitura, escrita e execução (rwx).</li>
                            </ul>
                        </li>
                    </ul>
                    Ação:
                    <ul>
                        <li>(<b>+</b>) Adicionar permissão;</li>
                        <li>(<b>=</b>) Especificar permissão;</li>
                        <li>(<b>-</b>) Remover permissão.</li>
                    </ul>
<small><pre><code>
<u>Exemplos</u>:
chown novoUser arq1 (alterar usuário proprietário do arquivo 'arq1' para 'novoUser')
chgrp novoGrupo arq1 (alterar grupo proprietário do arquivo 'arq1' para 'novoGrupo')
chown novoUser:novoGrupo arq1 (alterar usuário e grupo proprietário do 'arq1')

chmod u-rwx arq1 (usuário sem permissões)
chmod g+w arq1 (grupo com permissão de escrita)
chmod o=w (outros somente com permissão de escrita)
chmod a+x arq1 (all, user/group/others, com permissão de execução)
chmod ugo=rwx arq1 (permissão total para user/group/others)
chmod uo=,g=rx arq1 (usuário e outros sem permissões, grupo com leitura e execução)
chmod u+rw,g-rw,o=rx (ou 'o-w+rx') arq1 (usuário adiciona leitura e escrita, grupo remove leitura e escrita, outros com leitura e execução)
chmod -Rv a=rwx dir1/ (permissão total e recursiva para todos, no diretório 'dir1'. -v para verbose)

chmod 764 arquivo (proprietário(7) com leitura/escrita/execução, grupo(6) com leitura/escrita, outros(4) com somente leitura)
chmod 40 arquivo (proprietário não foi modificada, grupo(4) somente leitura, outros(0) nenhuma)

<u>Permissões especiais</u>:
chmod 1755 dir1/ (o '1' representa permissão sticky bit, ou restricted deletion flag, representada com '-t' no final do arquivo ao 'ls'. Somente para diretórios. Impede que usuários não proprietários de deletar ou renomear arquivos no diretório. Diretórios geralmente representados com fundo azul)
chmod 2755 arq1 (ou 'g+s' em simbólico ou '2' octal. Permissão SGID ou bit set group id, concede permissão aos privilégios do grupo proprietário, incluindo respectivos arquivos, se diretório. Representa 's' no lugar do 'x' nas permissões do grupo. Geralmente representados por fundo amarelo)
chmod 6755 arq1 ('4' octal, incluindo SGID. SUID ou set user id, representa um 's' no lugar do 'x' nas permissões do usuário. Aplicado a arquivos regulares. Semelhante ao SGID, mas aplicado ao usuário proprietário. Geralmente representados com fundo vermelho)

chattr +a arq1 (permite gravar apenas abrindo arquivo acrescentar modo)
chattr +c arq1 (permite que arquivo seja compactado/descompactado automaticamente)
chattr +d arq1 (garante que programa ignore excluir arquivos durante o backup)
chattr +i arq1 (torna o arquivo inalterado, não podendo ser excluído, alterado, renomeado ou vinculado)
chattr +s arq1 (permite que arquivo possa ser excluído com segurança)
chattr +S arq1 (garante que arquivo é modificado, as alterações são gravadas no modo síncrono, como com a
sincronia)
chattr +u arq1 (permite recuperar conteúdo de arquivo, mesmo se está cancelado)
lsattr (listar atributos especiais, pode ser utilizado com parâmetros de 'ls')
lsattr arq1 (listar atributos especiais do arquivo)
</code></pre></small>

                    <h5>Lançador:</h5>
                    <p>Atalho de binário no desktop environment, em arquivo '.desktop'. Lançadores globais (disponíveis para todos usuários) ficam em '/usr/share/applications', lançadores locais (disponíveis somente para usuário da sessão) ficam em '~/.local/share/applications'.</p>
<small><pre><code>
<b>Conteúdo de arquivo do lançador</b>:
[Desktop Entry]
Type=Application
Version=1.0
Name=Nome do binário
Comment=Descrição do binário
Icon=Diretório do ícone do binário
Exec=Diretório do executável do binário
Terminal=Abrir shell (true ou false)
StartupNotify=Notificação quando executado (true ou false)
Categories=Categoria do binário
</code></pre></small>
                    Categorias:
                    <ul>
                        <li>Configurações: Settings;</li>
                        <li>Desenvolvimento: Development; Documentation;</li>
                        <li>Educação: Education;</li>
                        <li>Ciência: Science;</li>
                        <li>Escritório: Office;</li>
                        <li>Gráficos: Graphics</li>
                        <li>Rede: Network;</li>
                        <li>Jogos: Game;</li>
                        <li>Multimídia: AudioVideo;Audio;Video;AudioVideoEditing;</li>
                        <li>Sistema: System;</li>
                        <li>Utilitários: Utility.</li>
                    </ul>

                    <h5>Processos:</h5>
                    <p>No Linux, o gerenciamento de processos segue padrão POSIX. Processo é um binário que, quando executado, consome recursos do dispositivo. Possui ciclo de vida (stat), time (tempo usado pelo processador no processo), CMD (binário que iniciou o processo), recursos e usuário proprietário. Todo processo é identificado pelo <b>PID</b> (process identification) e, em alguns casos, <b>PPID</b> (parent process identification), com prioridade de execução (nice), do -20 (máxima) ao 19 (mínima) e 0 (padrão). O root possui permissão para alterar prioridades. Processos criados pelo root têm prioridade 0. Processos criados por usuário comum têm prioridade 10 (baixa). Processos em realtime (normalmente internos do kernel) possuem prioridade 1 a 99. Processos convencionais possuem têm prioridade 100 (maior) até 139 (menor), sendo 120 (padrão) e rt (realtime). A prioridade padrão (PRI/PR), diferente da nice (NI), é definida automaticamente no escalonamento definido pelo kernel. Processos em execução possuem seus diretórios em '/proc', nomeados por PID. Processos podem ser inicializados pelos gerenciadores <i>systemctl</i> e <i>systemd</i>. Comando 'top' mostra lista de processos. No 'top', load average é a média de tempo para execução de cada processo (geralmente deve-se manter abaixo de 3). A gestão do processo ocorre via sinais de kill (comando 'kill -l' mostra todos sinais de kill). Processos em 1º plano são foreground (binários executados em shell), processos em 2º plano são background. Toda vez que um processo é executado em background, estará executando em subshell. Arquivo '/proc/cmdline' armazena strings do kernel na inicialização.</p>
                    Componentes do processo:
                    <ul>
                        <li>Estado (stat);
                            <ul>
                                <li>(<b>R</b>) running (em execução, consome recursos);</li>
                                <li>(<b>T</b>) stopped (parado, não consome recursos);</li>
                                <li>(<b>S</b> ou <b>D</b>) sleeping (hibernando ou com dificuldades de retornar à execução, não consome recursos);</li>
                                <li>(<b>Z</b>) zoombie (travado, não executa funções, consome recursos);</li>
                                <li>(<b>X</b>) finish (finalizado, não consome recursos).</li>
                            </ul>
                        </li>
                        <li>Recursos: Recursos de hardware ou sistema (libraries);
                            <ul>
                                <li>(<b>VSZ</b>) virutal size (tamanho virtual);</li>
                                <li>(<b>RSS</b>) resident set size (memória utilizada);</li>
                                <li>(<b>SHR</b>) memória compartilhada;</li>
                                <li>(<b>tty ?</b>) processo daemon (execução independente de tty);</li>
                                <li>(stat <b>l</b> ou <b>L</b>) processo com recurso bloqueado na memória.</li>
                            </ul>
                        </li>
                        <li>Proprietário: Usuário que gerou o processo, com permissão para modificá-lo. Usuário comum é proprietário somente de seus processos. root é proprietário de todos processos;</li>
                        <li>Prioridade: Quantidade disponibilizada de recursos fornecidos;
                            <ul>
                                <li>(stat <b>&lt;</b> ou <b>N</b>) prioridade menor que normal;</li>
                                <li>(stat <b>&gt;</b>) prioridade maior que normal;</li>
                                <li>(stat <b>s</b>) líder da sessão;</li>
                                <li>(stat <b>+</b>) executando em 1º plano;</li>
                                <li>(<b>NI</b>) nice/renice, valor de prioridade definido na criação/alteração do processo;</li>
                            </ul>
                        </li>
                        <li>PID, PPID: Identificadores do processo.</li>
                    </ul>
<small><pre><code>
<b>Ver processos da sessão, tty e usuário atual</b> (process status): 'ps -ef' ou 'ps -aux' ou 'ps -r' (-r para somente running)
<b>Similar acima, mas em todos tty</b>: ps u
<b>Ver processos, filtro</b>: 'ps -ef | grep init' (todos processos 'init') ou 'ps --pid numPID' ou '--ppid numPPID' (filtro por id)
<b>Ver processos do usuário, em 1º e 2º plano, em todos tty</b>: ps a
<b>Ver processos, forma personalizada</b>: ps ax -o user,pid,ppid,%cpu,%mem,stat,start,command | head -3
<b>Listar processos e processos filhos</b>: 'ps faux' ou 'ps -ef'
<b>Ver PID do processo</b>: pidof nomeProcesso (pidof init)
<b>Mostrar dados de processo</b>: top numPID ('q' para sair)
<b>Processos de usuário específico</b>: top -u usuario
<b>Processos de arquivo específico</b>: fuser nomeArquivo
<b>Processos em árvore</b>: pstree
<b>Processos enviados para background pelo usuário da sessão atual</b>: jobs (-l mostra PIDs, -r somente running, -s somente stopped)
<b>Encerrar processo</b>: kill -15 numPID (função sigterm, similar a 'kill numPID' ou 'kill -SIGTERM numPID')
<b>Parar processo</b>: kill -19 numPID (sigstop)
<b>Parar processo em background</b>: ctrl+z (sigquit, similar a 'kill -3')
<b>Matar processo</b>: kill -9 numPID (sigkill)
<b>Matar processo pelo nome</b>: pkill nomeProcesso (ou 'pkill -9 nomeProcesso')
<b>Continuar processo stopped</b>: kill -18 numPID (sigcont)
<b>Criar processo com prioridade</b>: nice -n -10 nomeProcesso (prioridade -10)
<b>Matar todos processos de software</b>: 'killall nomeSoftware'
<b>Alterar prioridade</b>: 'renice numPrioridade -p numPID' ou 'nice -n numPrioridade nomeProcesso'
<b>Ignorar sinais ao processo</b>: Torná-lo daemon, para mantê-lo em execução mesmo com shell fechado, 'nohup ping 8.8.8.8 &' (sighup. As saídas do nohup ficam em 'nohup.out')
<b>Retomar processo parado em background, para foreground</b>: fg idJob
<b>Retomar processo parado em foreground, para background</b>: bg idJob
<b>Enviar processo para ser executado em background</b>: nomeProcesso & (ou 'comando &')
<b>Ver carga do sistema</b>: uptime
</code></pre></small>

                    <h5>Mensagens do sistema:</h5>
                    <p>Registros (logs) do sistema são gerenciados pelo <i>syslog</i> ou seus derivados, <i>syslog-ng</i> ou <i>rsyslog</i>. O daemon de log coleta mensagens de arquivos em '/var/log'. Geralmente logs são armazenados em arquivos '.log'. Respectivamente, os logs 'messages' compõem-se de data e hora, host do log, service que gerou o log, PID do processo que gerou o log, e descrição do log. O <i>logrotate</i> implementa rotação/ciclo de log, criando/movendo/arquivando arquivos de grandes logs, a fim de simplificar/organizar/otimizar a organização dos arquivos de logs (geralmente arquivos possuem nome 'dataHoraLog.log' ou 'log1.log' 'log2.log' etc). Comando <i>journalctl</i> faz leitura dos logs(diário) do systemd.</p>
                    <ul>
                        <li><i>/var/log/auth.log</i>: Informações sobre autenticação;</li>
                        <li><i>/var/log/wtmp</i>: Informações de logins bem sucedidos (comando 'last' interpreta o arquivo);</li>
                        <li><i>/var/log/btmp</i>: Informações de logins malsucedidas (comando 'lastb' interpreta o arquivo);</li>
                        <li><i>/var/log/kern.log</i>: Informações do kernel;</li>
                        <li><i>/var/log/syslog</i>: Informações do sistema;</li>
                        <li><i>/var/log/messages</i>: Dados do sistema e binários.</li>
                    </ul>

                    <h5>Shell script:</h5>
                    <p>Script de execução em shell Linux, em linguagem shell, arquivos com terminação '.sh'. Realizam manipulação em rotinas shell Linux. <span class="text-muted">#!/bin/bash</span> é o Shebang, interpretador do script, gerará um subshell para executar os códigos, não considerado comentário. Para executar shell script sem permissão de execução, deve-se executar '<span class="text-muted">source arquivo.sh</span>' (ou '. arquivo.sh', ou 'bash arquivo.sh'). Também, pode-se atribuir permissão de execução ao mesmo com '<span class="text-muted">chmod a+x arquivo.sh</span>' e executá-lo com '<span class="text-muted">./arquivo.sh</span>' (ou '/home/usuario/arquivo.sh'). Termos entre aspas simples são considerados string como todo. Termos entre aspas duplas consideram valores de variáveis.</p>
                    Variáveis internas do shell:
                    <ul>
                        <li>(<b>$0</b>) Nome do script;</li>
                        <li>(<b>$1</b>) 1º parâmetro passado depois do script;</li>
                        <li>(<b>$2</b>) 2º parâmetro passado depois do script;</li>
                        <li>(<b>$3</b>) 3º parâmetro passado depois do script;</li>
                        <li>(<b>$#</b>) Quantidade de parâmetros passados depois do script;</li>
                        <li>(<b>$$</b>) PID gerado na execução do script;</li>
                        <li>(<b>$@</b>) Todos parâmetros passados depois do script;</li>
                        <li>(<b>$?</b>) Valor de retorno do comando executado.</li>
                    </ul>
<small><pre><code>
<b><u>Shell script para criação de 3 diretórios, arquivo 'teste.sh'</u></b>:
#!/bin/bash
X=1
while [ $X -le 3 ];
do
    mkdir dir$X
    echo "dir$X criado"
    ((X=$X+1))
done
echo "Concluído!"
SAIDA=$( ls -l )
echo $SAIDA
<span class="text-muted">#Exemplo comentário</span>

<b><u>Shell script de input de dado</u></b>:
read -p "Informe o nome:" NOME
echo $NOME
</code></pre></small>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Localização</h4>
                <div class="card-body">
                    <p>Encontrar arquivos no sistema. Comando 'locate' realiza pesquisa simples, utilizando base de dados (updatedb) ao invés de recursividade nas buscas (Ex: '<span class="text-muted">locate howto</span>'). Comando 'find' utiliza recursividade nas buscas.<br>Sintaxe: <span class="text-danger">find [diretórioBusca] [opção] [termo/expressãoBusca]</span></p>
<small><pre><code>
<u><b>Exemplos de buscas</b></u>:
<b>Arquivos com 'teste' no diretório atual</b>: find teste
<b>Arquivos com final '.conf' no diretório '/etc'</b>: find /etc -name *.conf
<b>Limitar recursividade em diretórios</b>: find /etc -maxdepth 1 -name *.conf (apenas 1 diretório, ou seja, o atual)
<b>Arquivos acessados minutos atrás</b>: find / -amin -5 (últimos 5min)
<b>Arquivos acessados dias atrás</b>: find / -atime 10 (acessados 10 dias atrás)
<b>Arquivos por id do usuário</b>: find / -uid 1000 (arquivos do usuário 1000)
<b>Arquivos por nome do usuário</b>: find / -user root (arquivos do root)
<b>Arquivos por permissão</b>: find / -perm 644 (arquivos de permissão 644)
<b>Arquivos por tamanho</b>: find / -size +50M (arquivos com mais de 50 megabytes)
<b>Arquivos por tipo (bloco, caractere, diretório...)</b>: find /dev -type b (arquivos de bloco)
<b>Arquivos regulares vazios</b>: find / -type f -empty
<b>Arquivos executando nos últimos minutos</b>: find / -cmin -60 (últimos 60min)
<b>Diretórios modificados nos últimos dias</b>: find / -mtime 50 (últimos 50 dias)
<b>Diretórios modificados entre datas</b>: find / -mtyme +50 -mtyme -100 (entre últimos 50 e 100 dias)
</small></pre></code>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Ajuda</h4>
                <div class="card-body">
                    <ul>
                        <li><b>how-to</b> (cookbook): Documentos, disponíveis em '/usr/share/doc', focados em necessidade específica, como montar um firewall. Possuem formatos HTML, Markdown, entre outros (Ex: how-to do iptables estão em '/usr/share/doc/iptables');</li>
                        <li><b>man page</b>: Manuais de ajuda geral, via comando 'man'. Há o termo com o nº do manual indicado ('gzip(1)' é o man1 do gzip). Sintaxe: <span class="text-danger">man [sessão] &lt;termo&gt;</span>. Sessão pode alterar manual do comando (Ex: 'man passwd' é man1 do comando passwd, 'man 5 passwd' é man5 do arquivo de configuração passwd). Comando 'catman' atualiza a base de dados dos manuais. Manuais estão em '/usr/share/man'. Cada manual possui 11 seções de organização de conteúdo, sendo padronizados globalmente (nome, sinopse, descrição, opções/parâmetros, argumentos, arquivos, exemplos, veja mais, diagnósticos, direitos autorais e bugs). Além disso, existem 9 categorias de manuais. Comandos <b>yelp</b> e <b>xman</b> são ferramentas GUI para tal;
                            <ul>
                                <li>man 1: Binários e executáveis;</li>
                                <li>man 2: Rotinas do sistema Linux e linguagem C;</li>
                                <li>man 3: Rotinas e libraries da linguagem C;</li>
                                <li>man 4: Arquivos especiais (dispositivos em '/dev');</li>
                                <li>man 5: Arquivos de configurações e convenções;</li>
                                <li>man 6: Games;</li>
                                <li>man 7: Diversos (macros textuais, por exemplo, regex);</li>
                                <li>man 8: Super binários;</li>
                                <li>man 9: Rotinas internas do kernel.</li>
                            </ul>
                        </li>
                        <li><b>help</b>: Providencia manuais de ajuda específicos para binários internos (Ex: 'help type' ajuda para comando type). Binários externos são executados com '--help' (Ex: 'cd --help');</li>
                        <li><b>info</b>: Info pages são similares às man pages, sendo em formato HTML, possuindo mais recursos de navegação, como hyperlinks. Sintaxe: <span class="text-danger">info [termo]</span> (Ex: 'info vim');</li>
                        <li><b>whatis</b>: Busca por referências idênticas (Ex: 'whatis passwd'). Comando '<span class="text-muted">man -f termo</span>' é similar;</li>
                        <li><b>which</b>: Mostra localização do binário (Ex: 'which ls');</li>
                        <li><b>apropos</b>: Busca por referências similares (Ex: 'apropos email address'). Comando '<span class="text-muted">man -k termo</span>' é similar;
                            <ul>
                                <li>(<b>-d</b>): Exibir mensagens de depuração;</li>
                                <li>(<b>-v</b>): Verbose, exibir detalhes do andamento da pesquisa;</li>
                                <li>(<b>-e</b> ou <b>--exact</b>): Busca por referência idêntica;</li>
                                <li>(<b>-w</b> ou <b>--wildcard</b>): Busca com expressões regulares;</li>
                                <li>(<b>-a</b> ou <b>--and</b>): Busca concatenada de 2 ou mais termos que se correspondam;</li>
                                <li>(<b>-l</b> ou <b>--long</b>): Resultado de saída sem quebra de linha;</li>
                                <li>(<b>-C</b>): Dispensar padrão (/ manpath), trocando-o por arquivo de configuração personalizado;</li>
                                <li>(<b>-L</b>): Definir diretório da busca;</li>
                                <li>(<b>-m</b> ou <b>--systems</b>): Usar man pages externas;</li>
                                <li>(<b>-M</b> ou <b>--manpath</b>): Definir caminho de busca das man pages para PATH ao invés do $MANPATH padrão;</li>
                                <li>(<b>-s</b> ou <b>--section</b> ou <b>--sections</b>): Busca em sessões específica (separadas por '<b>:</b>');</li>
                                <li>(<b>-r</b> ou <b>--regex</b>): Interpretar termo pesquisado como regex.</li>
                            </ul>
                        </li>
                        <li><b>whereis</b>: Localizar binário e manual do comando (Ex: 'whereis ls' mostrará '/usr/bin/ls' e '/usr/share/man/man1/ls.1.gz').
                            <ul>
                                <li>(<b>-b</b>): Buscar somente localização do binário;</li>
                                <li>(<b>-m</b>): Somente man pages;</li>
                                <li>(<b>-s</b>): Somente fontes;</li>
                                <li>(<b>-u</b>): Buscar termos incomuns, como arquivos de origem ou binários;</li>
                                <li>(<b>-B</b>): Alterar/limitar locais de pesquisa por binários;</li>
                                <li>(<b>-M</b>): Alterar/limitar locais de pesquisa por man pages;</li>
                                <li>(<b>-S</b>): Alterar/limitar locais de pesquisa por fontes;</li>
                                <li>(<b>-f</b>): Termina última lista de diretórios e sinaliza início dos nomes dos arquivos (deve ser usado com opções -B , -M ou -S).</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Nano editor</h4>
                <div class="card-body">
                    <p>Editor CLI de texto, baseado no Joe, presente na maioria das distros Linux. Carregado automaticamente no modo de edição. Para utilizá-lo basta digitar nano, seguido do nome do arquivo que deseja criar/editar. O arquivo '/etc/nanorc' realiza a inicialização do GNU nano. Atalhos do GNU nano:</p>
<small><pre><code>
<b>ctrl+g</b>: Ajuda
<b>ctrl+k</b>: Recortar linha
<b>ctrl+u</b>: Colar linha recortada
<b>ctrl+_</b>: Ir para linha informada
<b>ctrl+y</b>: Sobir 1 página
<b>ctrl+v</b>: Descer 1 página
<b>alt+/</b>: Ir para última linha
<b>alt+\</b>: Ir para 1ª linha
<b>ctrl+a</b>: Mover cursor para início da linha
<b>ctrl+e</b>: Mover cursor para fim da linha
<b>ctrl+c</b>: Informações sobre a posição do cursor
<b>ctrl+j</b>: Justificar texto
<b>ctrl+t</b>: Acionar corretor ortográfico (Se comando 'spell' instalado)
<b>ctrl+w</b>: Pesquisar ('alt+w' avança para próxima ocorrência)
<b>ctrl+w texto, ctrl+r novoTexto</b>: Substituir texto ('y' seleciona texto, 'a' substitui todas ocorrências)
<b>alt+a</b>: Ativar/desativar seleção de texto (setas direcionais fazem a seleção quando ativado)
<b>alt+6</b>: Copiar seleção
<b>ctrl+o</b>: Salvar arquivo (pode salvar uma cópia do mesmo em outro local, com outro nome também, 'salvar como')
<b>ctrl+x</b>: Sair do editor
<b>alt+u</b>: Desfazer última alteração (undo)
<b>alt+e</b>: Refazer última alteração, se desfeita (redo)

O nano possibilita a abertura de diversos arquivos ao mesmo tempo
<b>alt+,</b>: Mover para arquivo à esquerda (ou <i>alt+&lt;</i>)
<b>alt+.</b>: Mover para arquivo à direita (ou <i>alt+&gt;</i>)
</small></pre></code>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Vim editor</h4>
                <div class="card-body">
                    <p>Editor CLI, evolução do vi, o vim (vi improved), sendo <b>gVim</b> sua versão GUI e <b>neovim</b> sua evolução CLI. Possui vários modos, sendo iniciado no <i>ex mode</i> (modo de comandos e visualização), onde as teclas têm função de comandos e somente visualização do conteúdo do arquivo. Para criar/editar conteúdo de arquivo, deve-se entrar no <i>insert mode</i> (modo de inserção/edição), com tecla 'i', onde as teclas têm função de texto comum. Tecla 'esc' sai dos modos, retornando ao ex mode. Arquivo de configuração do vim é '/etc/vim/vimrc'. Sintaxe: <span class="text-danger">vim [parâmetros] [arquivo(s)]</span>. O vim aceita expressões regulares para pesquisa, via comando '/temoOUexpressao' (ou '?termo' para pesquisa reversa). 'enter' para pesquisar. O cursor se moverá para 1ª correspondência que for encontrada. 'n' para seguir às próximas correspondências, 'N' para retroceder. Abaixo, comandos do ex mode:</p>
<small><pre><code>
<u><b>Atalhos gerais</b></u>:
(<b>:i</b>) Entrar no modo Inserção
(<b>:w</b>) Salvar arquivo
(<b>:w arquivo</b>) Salvar cópia do arquivo atual como arquivo
(<b>:w!</b>) Forçar salvar arquivo atual
(<b>:1</b>) Ir para linha 1 ou qualquer nº fornecido
(<b>:e arquivo</b>) Abrir arquivo
(<b>:q</b>) Sair, qiando não há alterações no arquivo
(<b>:q!</b>) Sair forçadamente, sem salvar alterações no arquivo
(<b>:wq</b>) Sair e salvar arquivo (mesmo que ':x')
(<b>:u</b>) Desfazer última ação
(<b>ctrl+r</b>) Repetir comando
(<b>:X</b>) Criptografar arquivo
(<b>:set nu</b>) Ativar linhas numeradas (':set nu!' para desativar)
(<b>:syntax on</b>) Ativar syntax highlighting (para ativar, descomentar linha no arquivo de configuração, removendo as aspas da mesma)

<u><b>Movimentações</b></u>:
(<b>gg</b>) Ir para início do arquivo
(<b>G</b>) Ir para final do arquivo
(<b>36G</b>) Ir para 36ª linha
(<b>M</b>) Ir para linha do meio da tela
(<b>h</b>) Voltar 1 caractere ('5h' moverá cursor 5 caracteres para esquerda)
(<b>l</b>) Avançar 1 caractere
(<b>H</b>) Ir para 1ª linha exibida na tela
(<b>L</b>) Ir para última linha exibida na tela
(<b>J</b>) Juntar linha atual com linha seguinte
(<b>k</b>) Subir 1 linha
(<b>j</b>) Descer 1 linha
(<b>w</b>) 1 palavra para direita ('3w' moverá cursor 3 palavras para direita)
(<b>b</b>) 1 palavra para esquerda
(<b>^</b>) Ir para início da linha
(<b>$</b>) Ir para fim da linha
(<b>ctrl+B</b>) Voltar 1 página
(<b>ctrl+F</b>) Avançar 1 página
(<b>ctrl+w+s</b>) Criar janelas verticais
(<b>ctrl+w+v</b>) Criar janelas horizontais
(<b>ctrl+ww</b>) Movimentar entre janelas
(<b>F1</b>) Exibir tela de ajuda (':q' para sair)

<u><b>Manipulações</b></u>:
(<b>u</b>) Desfazer modificação (undo)
(<b>s</b>) Deletar caractere atual e colar linha
(<b>S</b>) Deletar linha atual e colar linha
(<b>dgg</b>) Deletar a partir da linha visual do topo até linha do cursor
(<b>yw</b>) Copiar palavra sob cursor
(<b>dw</b>) Recortar palavra sob cursor
(<b>Y</b>) Copiar linha
(<b>y</b>) Copiar trecho selecionado ('3y' copiar próximas 3 letras, cursor + 2 letras seguintes)
(<b>D</b>) Recortar trecho selecionado
(<b>uu</b>) Recortar linha
(<b>V</b>) Selecionar linha(s), usando setas direcionais para seleção
(<b>v</b>) Selecionar palavra(s), usando setas direcionais para seleção
(<b>p</b>) Colar trecho selecionado/copiado após o cursor
(<b>P</b>) Colar trecho selecionado/copiado antes do cursor
(<b>r</b>) Substituir caractere atual (replace)
(<b>R</b>) Substituir conjunto de caracteres
(<b>yy</b>) Copiar linha atual (sem excluí-la)
(<b>3yy</b>) Copiar próximas 3 linhas (sem excluí-las)
(<b>yw</b>) Copiar próximas 3 linhas (sem excluí-las)

<u><b>Exclusões</b></u>:
(<b>x</b>) Excluir caractere sob cursor
(<b>dd</b>) Excluir linha atual ('3dd' excluir próximas 3 linhas)
(<b>dw</b>) Excluir palavra atual ('d3w' excluir próximas 3 palavras. 'd4h' excluir 4 caracteres à esquerda)

<u><b>Modificações</b></u>:
(<b>cc</b>) Mudar linha atual
(<b>cw</b>) Mudar palavra atual
(<b>c3w</b>) Mudar próximas 3 palavras
(<b>c5h</b>) Mudar 5 caracteres para esquerda
(<b>:%s/termo/termoNovoNome/g</b>) Substituir todos 'termo' por 'termoNovoNome'

<u><b>Insert mode</b></u>:
(<b>a</b>) Entrar no modo de inserção após cursor
(<b>A</b>) Entrar no modo de inserção no final da linha
(<b>i</b>) Entrar no modo de inserção antes do cursor
(<b>I</b>) Entrar no modo de inserção no início da linha
(<b>o</b>) Entrar no modo de inserção 1 linha em branco após cursor
(<b>O</b>) Entrar no modo de inserção 1 linha em branco antes do cursor
</small></pre></code>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Compactação e empacotamento</h4>
                <div class="card-body">
                    <ul>
                        <li><b>Empacotamento</b>: Quando vários arquivos são empacotados em 1 só arquivo;
                            <ul>
                                <li>tar: tape arquive, empacotador de arquivos, preservando metadados dos arquivos, tornando-os com final '.tar'. Sintaxe: <span class="text-danger">tar &lt;parâmetros&gt; &lt;arquivo.tar&gt; &lt;arquivo1&gt; [arquivo2(s)]</span>
                                    <ul>
                                        <li>(<b>-f</b> ou <b>--file</b>): Parâmetro obrigatório. Indicar destino do arquivo.tar resultante;</li>
                                        <li>(<b>-c</b> ou <b>--create</b>): Empacotar arquivo;</li>
                                        <li>(<b>-t</b> ou <b>--list</b>): Exibir conteúdo interno do empacotado;</li>
                                        <li>(<b>-v</b> ou <b>--verbose</b>): Exibir detalhes do empacotamento/desempacotamento na tela;</li>
                                        <li>(<b>-j</b> ou <b>--bzip2</b>): Compactar arquivo, com bzip2, ao empacotá-lo (gerará 'arquivo.tar.bz2');</li>
                                        <li>(<b>-J</b> ou <b>--xz</b>): Compactar arquivo, com xz, ao empacotá-lo (gerará arquivo.tar.xz);</li>
                                        <li>(<b>-z</b> ou <b>--gzip</b>): Compactar, com gzip, ao empacotá-lo (gerará arquivo.tar.gz);</li>
                                        <li>(<b>-x</b> ou <b>--extract</b>): Desempacotar arquivo empacotado.</li>
                                    </ul>
<small><pre><code>
<b>Empacotar</b>: tar -cf arquivoFinal.tar arquivoEmpacotar
<b>Desempacotar</b>: tar -xf arquivoPronto.tar
</code></pre></small>
                                </li>
                                <li>zip: Empacotador de arquivos, tornando-os com final '.zip'. Sintaxe: <span class="text-danger">zip &lt;parâmetros&gt; &lt;arquivo&gt; [arquivo2(s)]</span></li>
<small><pre><code>
<b>Empacotar</b>: zip arquivoFinal.zip arquivoEmpacotar
<b>Empacotar recursivamente</b>: zip -r arquivoFinal.zip diretorioEmpacotar
<b>Ver conteúdo de empacotado, sem extrair</b>: unzip -l arquivo.zip
<b>Desempacotar (extrair)</b>: unzip arquivo.zip
</code></pre></small>
                            </ul>
                        </li>
                        <li><b>Compactação</b>: Quando arquivo original é compactado em arquivo menor.
                            <ul>
                                <li>gzip: Compactador de arquivos, tornando-os com final '.gz'. Sintaxe: <span class="text-danger">gzip &lt;parâmetros&gt; &lt;arquivo&gt; [arquivo2(s)]</span>
                                    <ul>
                                        <li>(<b>-c</b> ou <b>--stdout</b>): Compactar arquivo;</li>
                                        <li>(<b>-d</b> ou <b>--decompress</b>): Descompactar arquivo.gz;</li>
                                        <li>(<b>-f</b> ou <b>--force</b>): Forçar compactação/descompactação;</li>
                                        <li>(<b>-l</b> ou <b>--list</b>): Exibir informação do arquivo compactado;</li>
                                        <li>(<b>-q</b> ou <b>--quiet</b>): Sair;</li>
                                        <li>(<b>-r</b> ou <b>--recursive</b>): Compactar recursivamente;</li>
                                        <li>(<b>-t</b> ou <b>--test</b>): Testar integridade do arquivo compactado;</li>
                                        <li>(<b>-v</b> ou <b>--verbose</b>): Exibir progresso da operação;</li>
                                        <li>(<b>&lt;nivel&gt;</b> ou <b>--fast</b> ou <b>--best</b>): Gerenciar grau da operação. Nível(1 a 9), com menos detalhes ao mais detalhes. Fast equivale 1, best equivale 9.</li>
                                    </ul>
<small><pre><code>
<b>Ver arquivo compactado.gz</b>: zcat arquivo.gz (há também 'zgrep', 'zless', 'zmore')
<b>Compactar</b>: gzip arquivo
<b>Compactar, redirecionando saída</b>: gzip -c arquivo &gt; arquivoCompactado.gz
<b>Descompactar</b>: gzip -d arquivo.gz
<b>Empacotar/compactar (tar/gzip)</b>: tar -czf arquivo.tar.gz diretorioArquivosAlvo
<b>Descompactar/desempacotar (gzip/tar)</b>: tar -xzf arquivo.tar.gz
<b>Descompactar/desempacotar (bzip2/tar)</b>: tar -xjvf arquivo.tar.bz2
</code></pre></small>
                                </li>
                                <li>bzip2: Compactador de arquivos, tornando-os com final '.bzip2'. Funcionamento similar ao gzip;</li>
<small><pre><code>
<b>Ver arquivo.bz2</b>: bzcat arquivo.bz2 (há também 'bzgrep', 'zless' e 'zmore')
<b>Compactar empacotado</b>: bzip2 dirEmpacotado.tar (gerará dirEmpacotado.tar.bz2)
<b>Descompactar</b>: bzip2 -d dirEmpacotado.tar.bz2
</code></pre></small>
                                <li>xz: Compactador de arquivos, tornando-os com final '.xz'. Funcionamento similar ao gzip;</li>
<small><pre><code>
<b>Compactar:</b> xz -c arquivo &gt; arquivoCompactado.xz
<b>Descompactar:</b> xz -d arquivoCompactado.xz
<b>Empacotar/compactar (tar/xz):</b> tar -cJf ./arquivo.tar.xz diretorioAlvo/
<b>Descompactar/desempacotar (xz/tar):</b> tar -xJf arquivo.tar.xz
</code></pre></small>
                                <li>gunzip: Descompactador, similar ao 'gzip -d' (Ex: 'gunzip arquivoCompactado.tar.gz');</li>
                                <li>bunzip2: Descompactador, similar ao 'bzip2 -d' (Ex: 'bunzip2 arquivoCompactado.tar.bz2');</li>
                                <li>unxz: Descompactador, similar ao 'xz -d' (Ex: 'unxz arquivoCompactado.tar.xz').</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Pacotes</h4>
                <div class="card-body">
                    <p>Repositórios de pacotes, os PPAs (personal package archive) são servidores que hospedam pacotes, a fim de instalá-los e atualizá-los. Distros possuem repositórios de pacotes, havendo possibilidade de adição de repositórios (mirror) extras, no conteúdo do arquivo (Debian) '/etc/apt/sources.list' ou em arquivo.list em '/etc/apt/sources.list.d'. Pacotes <i>sandbox</i> funcionam isoladamente, sem intervenções ao sistema (similar ao conceito de container). Nativamente, Linux possui os tipos de pacotes:</p>
                    <ul>
                        <li><b>Fonte</b>: Contém código fonte do software, arquivos de configuração, documentação, scripts de controle, manuais e bibliotecas fonte. Pode ser compilado em qualquer distro;</li>
                        <li><b>Binário</b>: Contém código binário, pré-compilado, do software, arquivos de configuração, documentação, scripts de controle, manuais e bibliotecas. Cada distro possui seu formato de pacote binário.</li>
                    </ul>
                    <p>Gerenciador de pacotes de baixo nível tem função de somente organizar o mesmo internamente na distro (extração), conforme abaixo, não possuindo tratamento de dependências. Gerenciador de pacotes de alto nível tem função de baixar (via repositórios descritos) e organizar pacotes internamente na distro, tratando dependências e configurações extras, direcionando os arquivos da seguinte forma:</p>
                    <ul>
                        <li>Configuáveis -&gt; /etc</li>
                        <li>Binários -&gt; /usr/bin</li>
                        <li>Super binaries -&gt; /usr/sbin</li>
                        <li>Libraries -&gt; /usr/lib</li>
                        <li>Processos -&gt; /proc</li>
                    </ul>
                    <p>Sintaxe de repositório (Debian): <span class="text-danger">&lt;tipoPacote&gt; &lt;protocoloAcesso:enderecoPacote&gt; &lt;versaoDistro&gt; &lt;classficacaoPacote&gt;</span><br>
                    Ex1: <span class="text-muted">deb http://ppa.launchpad.net/kdenlive/kdenlive-stable/ubuntu focal main</span><br>
                    Ex2: <span class="text-muted">deb cdrom:[Linux Mint 20.3 _Una_ - Release amd64 20220104]/ focal contrib main</span></p>
                    <ul>
                        <li>Tipo: deb (padrão) e deb-src (aponta ao código fonte);</li>
                        <li>Protocolo: HTTP e FTP;</li>
                        <li>Versão da distro: Codinome ou versão (stable, testing...);</li>
                        <li>Classificação do pacote.
                            <ul>
                                <li>main: Apenas pacotes free software;</li>
                                <li>contrib: Contém dependências de software proprietário;</li>
                                <li>nonfree: Código fonte fechado.</li>
                            </ul>
                        </li>
                    </ul>
                    <p>Existem gerenciadores de pacotes de alto nível externos, como <b>pip</b> (Python), <b>npm</b> (Node.js). Além disso, pacotes do tipo '<b>appimage</b>' funcionam em sandbox, podendo ser executados imediatamente, após baixados, com '<span class="text-muted">./pacote.appimage --install</span>', mediante permissão de execução. Além disso, pode-se instalar pacotes manualmente (pacotes fonte), fazendo download do arquivo empacotado compactado: Basta extraí-lo e, no diretório extraído, executar o arquivo './configure', após isso realizar o comando '<span class="text-muted">make</span>', seguido do comando '<span class="text-muted">make install</span>', seguido do '<span class="text-muted">make clean</span>'.</p>
                    
                    <h5>Debian (.deb):</h5>
                    <ul>
                        <li><b>dpkg</b> (Debian package): Gerenciador de pacotes (baixo nível);
<small><pre><code>
<b>Instalar pacote</b>: dpkg -i pacote.deb ('-v' para verbose)
<b>Remover pacote</b>: dpkg -r pacote
<b>Remover pacote e dependências</b> (purge): dpkg -p pacote
<b>Listar pacotes instalados</b>: dpkg -l
</code></pre></small>
                        </li>
                        <li><b>apt</b> (advanced package tool): Ou 'apt-get', gerenciador de pacotes (alto nível);
                            <ul>
                                Sintaxe: <span class="text-danger">apt [parâmetros] &lt;operação&gt; [pacote(s)]</span>
                                <li>(<b>-d</b>) download-only, realiza apenas download, não instala. Pacotes ficam em '/var/cache/apt/archives';</li>
                                <li>(<b>-f</b>) fix-broken, corrige erros gerados na operação;</li>
                                <li>(<b>-s</b>) simulate, simula operação, não realizando-a de fato;</li>
                                <li>(<b>-u</b>) show upgrade, lista pacotes que serão atualizados;</li>
                                <li>(<b>-y</b>) assume yes, assume confirmação de instalação diretamente;</li>
                                <li>(<b>--reinstall</b>) reinstala pacote já instalado.</li>
                            </ul>
<small><pre><code>
<u><b>Operações</b></u>:
<b>Instalar pacote</b>: apt install pacote (ou 'apt-get install pacote')
<b>Procurar pacote</b>: apt search termoBusca
<b>Informações sobre pacote</b>: apt info pacote
<b>Remover pacote</b>: apt remove pacote
<b>Remover pacote e dependências</b>: apt purge pacote
<b>Remover libraries não utilizadas</b>: apt autoremove
<b>Reinstalar pacote</b>: apt reinstall pacote
<b>Exibir detalhes de pacote</b>: apt show pacote
<b>Listar pacotes disponíveis</b>: apt list ('--installed' para listar somente instalados)
<b>Atualizar lista de repositórios</b> (update): apt update
<b>Atualizar pacotes</b> (upgrade): apt upgrade
<b>Atualizar distro</b> (dist-upgrade): apt dist-upgrade
<b>Atualizar pacotes e distro</b>: apt full-upgrade
<b>Identificar e corrigir falhas</b>: apt-check
<b>Esvaziar repositório local</b>: apt-clean (Esvazia '/var/cache/apt/archives')
<b>Adicionar PPA</b>: add-apt-repository ppa:nomeRepositorio
<b>Remover PPA</b>: add-apt-repository -remove ppa:nomeRepositorio
</code></pre></small>
                        </li>
                        <li><b>aptitude</b>: Gerenciador de pacotes (alto nível) externo, necessário instalar;
<small><pre><code>
<b>Entrar</b>: aptitude
<b>Procurar pacotes</b>: aptitude search pacote
<b>Informações sobre pacote</b>: aptitude info pacote (ou 'aptitude show pacote')
<b>Instalar pacote</b>: aptitude install pacote
<b>Atualizar pacotes</b>: aptitude safe-upgrade
</code></pre></small>
                        </li>
                        <li><b>synaptic</b>: Gerenciador de pacotes (alto nível) GUI para manipulação de repositórios e gestão de pacotes (basicamente um front-end do 'apt').</li>
                    </ul>

                    <h5>RHEL (.rpm):</h5>
                    <ul>
                        <li><b>rpm</b> (Red Hat package manager): Gerenciador de pacotes (baixo nível);
<small><pre><code>
<b>Instalar pacote</b>: rpm -i pacote.rpm ('-v' para verbose)
<b>Atualizar pacote</b>: rpm -U pacote.rpm
<b>Remover pacote</b>: dpkg -e pacote
<b>Listar pacotes instalados</b>: rpm -l
</code></pre></small>
                        </li>
                        <li><b>yum</b> (yellowdog updater modified): Gerenciador de pacotes (alto nível);</li>
                        <li><b>dnf</b> (dandified yum): Gerenciador de pacotes (alto nível) fork e evolução do yum. No RHEL, repositórios ficam em '/etc/yum.repos.d', cujos arquivos de repositórios possuem final '.repo';<br>
                            Sintaxe: <span class="text-danger">dnf [parâmetros] &lt;operação&gt; [pacote(s)]</span>
<small><pre><code>
<span class="text-muted">Os mesmos comandos dnf equivalem ao yum. Os parâmetros do apt são similares no dnf.</span>
<b>Instalar pacote</b>: dnf install pacote (ou 'dnf localinstall pacote' ou 'dnf localinstall pacote.rpm')
<b>Procurar pacote</b>: dnf search termoBusca
<b>Informações sobre pacote</b>: dnf info pacote
<b>Remover pacote</b>: dnf remove pacote (ou 'dnf erase pacote')
<b>Remover libraries não utilizadas</b>: dnf autoremove
<b>Reinstalar pacote</b>: dnf reinstall pacote
<b>Listar pacotes disponíveis</b>: dnf list ('list installed' para listar somente instalados)
<b>Atualizar lista de repositórios</b>: dnf check-update
<b>Atualizar pacotes</b>: dnf upgrade
<b>Atualizar distro</b> (dist-upgrade): dnf system-upgrade
<b>Atualizar pacotes e distro</b>: dnf distro-sync
<b>Identificar e corrigir falhas</b>: dnf check-update pacote
<b>Esvaziar repositório local</b>: dnf clean (Esvazia '/var/cache/dnf/{repo-name}/packages')
</code></pre></small>
                        </li>
                    </ul>
                    <h5>SUSE (.rpm):</h5>
                    <ul>
                        <li><b>ZYpp</b> (zypper): Gerenciador de pacotes (alto nível), similar ao yum;</li>
                    </ul>
                    <h5>Gentoo, Sabayon (ebuild):</h5>
                    <ul>
                        <li><b>portage</b>: Gerenciador de pacotes binários (Gentoo);</li>
                        <li><b>entropy</b> (equo): Gerenciador de binários compilados em portage (Sabayon).</li>
                    </ul>
                    <h5>Arch (.pkg.tar.xz):</h5>
                    <ul>
                        <li><b>pacman</b>: Gerenciador de pacotes (alto nível);</li>
                        <li><b>pamac</b>: Gerenciador de pacotes (alto nível), distro Manjaro, englobando repositórios oficiais, AUR, opcionalmente snap e flatpak.</li>
                    </ul>
                    <h5>Pacotes sandbox:</h5>
                    <ul>
                        <li><b>snap</b>: Gerenciador (proprietário) de pacotes sandbox. Binários ficam em '/snap/bin'. Snapstore é sua versão GUI;
<small><pre><code>
<b>Instalar pacote</b>: snap install pacote
<b>Instalar pacote</b> (outro canal): snap install --channel=edge pacote (Ou simplesmente '--edge'. Canais: stable, edge, latest, beta, candidate, classic...)
<b>Procurar pacote</b>: snap find pacote (ou "expressão de busca")
<b>Informações sobre pacote</b>: snap info pacote
<b>Listar pacotes disponíveis</b>: snap list ('--installed' para listar somente instalados)
<b>Remover pacote</b>: snap remove pacote
<b>Atualizar pacote</b>: snap refresh pacote (canal também permitido)
</code></pre></small>
                        </li>
                        <li><b>flatpak</b>: Gerenciador (free) de pacotes sandbox. Binários ficam globalmente em '/var/lib/flatpak' ou localmente em '/home/usuario/.local/share/flatpak. Flathub é sua versão GUI.
<small><pre><code>
<b>Instalar pacote</b>: flatpak install pacote
<b>Procurar pacote</b>: flatpak search pacote (ou "expressão de busca")
<b>Informações sobre pacote</b>: flatpak info pacote
<b>Listar pacotes disponíveis</b>: flatpak list ('--app' para listar somente instalados)
<b>Remover pacote</b>: flatpak uninstall pacote (ou 'repair' para reparar pacote)
<b>Atualizar pacote</b>: flatpak update pacote
</code></pre></small>
                        </li>
                    </ul>
                </div>
            </div>

        </div>
    </div>

    <div class="row my-3">
        <div class="accordion">
            <div class="accordion-item">
                <h2 class="accordion-header" id="headingTwo">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#contRelacionado" aria-expanded="false" aria-controls="contRelacionado">Conteúdo relacionado</button>
                </h2>
                <div id="contRelacionado" class="accordion-collapse collapse" aria-labelledby="headingTwo" data-bs-parent="#listaDesejos">
                    <div class="accordion-body">
                        <ul class="list-group list-group-flush">
                            <a href="../../posts/auditLogs/auditLogs.html" class="list-group-item list-group-item-action" target="_blank">Auditoria de Logs</a>
                            <a href="../../posts/post12.html" class="list-group-item list-group-item-action" target="_blank">XAMPP no Linux</a>
                            <a href="../../posts/post24.html" class="list-group-item list-group-item-action" target="_blank">Habilitar Bluetooth no Debian</a>
                            <a href="../../posts/post23.html" class="list-group-item list-group-item-action" target="_blank">Habilitar Bash autocomplete</a>
                            <a href="../../posts/post30.html" class="list-group-item list-group-item-action" target="_blank">Asteriscos na senha Shell</a>
                            <a href="../../posts/post32.html" class="list-group-item list-group-item-action" target="_blank">Complementos para Ubuntu</a>
                            <a href="../../posts/post33/post33.html" class="list-group-item list-group-item-action" target="_blank">MacOS no Ubuntu</a>
                            <a href="../../posts/post16/post16.html" class="list-group-item list-group-item-action" target="_blank">PostgreSQL no Debian</a>
                            <a href="../../posts/post22.html" class="list-group-item list-group-item-action" target="_blank">Postman no Linux</a>
                            <a href="../../posts/post21/post21.html" class="list-group-item list-group-item-action" target="_blank">PyCharm no Linux</a>
                            <a href="../../posts/post20/post20.html" class="list-group-item list-group-item-action" target="_blank">IntelliJ no Linux</a>
                            <a href="../../posts/post19/post19.html" class="list-group-item list-group-item-action" target="_blank">Eclipse no Linux</a>
                            <a href="../../posts/post29/post29.html" class="list-group-item list-group-item-action" target="_blank">Weka no Linux</a>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>


<!--Rodapé-->
<div class="row">
    <div class="col-sm-12 text-center bg-black text-light pt-4 pb-3">
        <p>Elaborado por Mateus Schwede<br><small class="text-muted">ubsocial.github.io<br>LPI000573399</small></p>
    </div>
</div>

</div>
</body>
</html>