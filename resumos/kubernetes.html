<!doctype html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ovo&family=Qwitcher+Grypen&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="../anexos/icons/logoTit.png">
    <link rel="stylesheet" href="../estilo.css">
    <title>UB Social</title>
</head>
<body>
<div class="container-fluid">


    <div class="row">
        <div class="col-sm-12" id="menu">
            <nav class="navbar fixed-top navbar-expand-lg navbar-light bg-light shadow">
                <div class="container-fluid">
                    <a id="serifada" class="navbar-brand" href="../index.html"><img src="../anexos/icons/logo.png" id="logo"> UB Social</a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                    <div class="collapse navbar-collapse" id="navbarNav">
                        <ul class="navbar-nav">
                            <li class="nav-item"><a class="nav-link" href="../index.html">Home</a></li>
                            <li class="nav-item"><a class="nav-link" href="../contato.html">Contato</a></li>
                            <li class="nav-item"><a class="nav-link" href="../livros.html">Livros</a></li>
                        </ul>
                    </div>
                </div>
            </nav>
        </div>
    </div>

    <div class="row">
        <div class="col-sm-12" id="titulo1">
            <h1 id="serifada">Kubernetes</h1>
            <h6><strong>Conceitos básicos de Kubernetes K8s</strong><br><br><span class="badge bg-warning text-dark">Resumo em construção</span></h6>
            <a href="../index.html" class="btn btn-link" id="btnLink">Voltar</a><br><br>
            <a class="btn btn-link" id="btnLink" href="" target="_blank">Github do projeto</a><br><br>
            <a class="btn btn-link" id="btnLink" href="https://kubernetes.io/pt-br" target="_blank">Site oficial e documentação</a>
        </div>

        <div class="col-sm-12">
            <h4>Problemática</h4>
            <p id="textoPost">Nos primórdios, para cada serviço em uma aplicação (Apache, MySQL, nginx...) era necessária uma máquina para alocá-lo, resultando-se em vários servidores para rodar um site que necessitasse dessas várias aplicações, resultando em capacidade subutilizada. Com a chegada da Virtualização, tudo fora executado em máquina física única, porém há muito gasto de hardware na alocação e cotidiano. Dessa forma, havia-se a Consolidação do Servidor, onde que os servidores que não estavam sendo utilizados, em alguns momentos de pouco fluxo, eram desligados. Quando a necessidade de carga era maior, os demais servidores eram novamente ligados, alocando novamente as outras VMs que haviam sido movidas para o único servidor no início (Live Migration). Com o surgimento dos Containers, constituiram-se as aplicações isoladas, descartou-se a necessidade de replicar stacks do SO, como duplicação de libraries, a própria infra do SO e trazendo, com isso, maior desempenho, facilidade de manutenção e leveza.</p>
            
            <br><h4>Conceito</h4>
            <p id="textoPost">Kubernetes (K8s) é ferramenta de código aberto para automatizar implantação gerenciamento e escalonamento de aplicações conteinerizadas, automatizando, com isso, toda a infraestrutura de aplicações. A <b>Orquestração</b> gerenciará os containers entre os servidores e os ativará/desativará de acordo com a necessidade de carga no cluster, escalando recursos e corrigindo problemas. O Kubernetes pode ser utilizado em Cluster Single Node (1 só servidor) ou Cluster padrão (1-N Master Node (Máquina Mestre/gerenciadora), N Slaves (Máquinas Escravas/gerenciada))</p>
            <ul>
                <li>Quando um node que aloca recursos tem pane, os containers nele serão perdidos?</li>
                <li>Se há 10 réplicas da aplicação 1.0 no cluster, e insiro uma réplica da 1.1, como as demais serão atualizadas?</li>
                <li>Como escalar o software para lidar com o aumento da demana?</li>
            </ul>

            <br><h4>Arquitetura K8s</h4>
            <img src="../anexos/kubernetes/arquitetura.jpg" width="350px" height="auto">
            <p id="textoPost">Orquestrar tarefas de gerenciamento. Pode ser instalado em modo single ou cluster. O cluster é formado por nós master e worker, onde o master é node de interação com o usuário. Em grandes estruturas, podem haver mais de 1 master, para o caso de falhas e correção de problemas.</p>
            <ul>
                <li><b>Master</b>: Executa os componentes do plano de controle;</li>
                <li><b>Worker</b>: Geralmente executa os Containers.</li>
            </ul>
            <p>Componentes:</p>
            <ul>
                <li><b>kubeadm</b>: Automatiza grande parte do processo de criação/instalação do cluster;</li>
                <li><b>kubelet</b>: Componente essencial do K8s que lida com a execução de Pods. Atua como um agente em cada node, intermediando (interface) as trocas de mensagens entre API server e Docker runtime. Tecnicamente, faz interação com o Docker e kube-apiserver;</li>
                <li><b>kubectl</b>: CLI de interação com o K8s cluster.</li>
            </ul>
            <p><b>Pod</b>:</p>
            <img src="../anexos/kubernetes/pod.jpg" width="350px" height="auto"><br>
            <img src="../anexos/kubernetes/pod2.jpg" width="450px" height="auto">
            <p id="textoPost">Menor e mais básica estrutura do K8s, criada para abstrair o conceito de Container. Consiste de 1 ou mais Containers, recursos de armazenamento (Volumes) e 1 único ID e IP na rede do cluster K8s. Utiliza-se vários Containers dentro de um Pod geralmente em que hajam vários processos, processos em batch (lote) e demais tarefas pesadas (Ex: Um Container Web Service recebe outra Imagem, que deverá ser processada pelo mesmo, ou seja, quando à 'relações' entre Containers em 1 mesmo Pod).</p>
            <p>Ciclo de Vida:</p>
            <img src="../anexos/kubernetes/pod3.jpg" width="350px" height="auto">
            <ul>
                <li><b>Pending</b>: Pod foi aceito pelo K8s, mas 1 ou mais Containers ainda não foram criados. Isso inclui tempo de escalonamento e tempo de download da Imagem;</li>
                <li><b>Running</b>: Pod foi alocado em um node e todos os Containers foram criados. Pelo menos 1 Container deve estar em execução, ou no processo de (re)inicialização;</li>
                <li><b>Succeeded</b>: Containers do Pod terminaram com sucesso;</li>
                <li><b>Failed</b>: Containers do Pod terminaram, pelo menos 1 deles com falha (status!=zero ou terminado pelo sistema);</li>
                <li><b>Unknown</b>: Por alguma razão, o estado do Pod não pode ser obtido. Tipicamente por causa de erro de comunicação entre node e Pod.</li>
            </ul>
            
            <p><b>Control Plane</b>:</p>
            <img src="../anexos/kubernetes/controlPlane.jpg" width="450px" height="auto">
            <p><small class="text-muted"><u>Legenda</u>: Minion é worker node</small></p>
            <ul>
                <li><b>etcd</b>: Provê sistema distribuído e compartilhado para armazenar o estado do cluster, sendo os dados armazenados em formato chave-valor (Informações como status do node master, status dos workers, status de Pods, etc). O etcd é executado, no K8s, como um Pod do mesmo;</li>
                <li><b>kube-apiserver</b>: Serve a API do K8s, baseada em REST, requisições via YAML (yml) que serão convertidas em JSON pelo kubectl;</li>
                <li><b>kube-controller-manager</b>: Pacote com diversos componentes de controle (Executa ações como verificação de funcionamento de Pods e, se houverem erros, criará novos Pods);</li>
                <li><b>kube-scheduler</b>: Escalona os Pods para serem executados nos nodes (Quando o Pod é criado, será escalonado para o node mais ideal). Pode também ser manipulado via usuário para escalonamento personalizado (Exemplo, escalonar Pods somente para as máquinas com GPU);</li>
                <li><b>kube-proxy</b>: Trata da comunicação entre nodes, adicionando regras ao firewall (Como em iptables, para abertura e redirecionamento de portas, túneis, etc).</li>
            </ul>
            <p id="textoPost">Tem-se também Registry, sendo geralmente em repositório local do Docker e outro remoto, como Dockerhub.</p>

            <br><h4>Rede no K8s</h4>
            <img src="../anexos/kubernetes/rede.jpg" width="350px" height="auto">
            <p id="textoPost">O modelo de redes do K8s envolve a criação de redes virtuais (Rede overlay) no cluster. Cada Pod do cluster tem um IP único (Externo ou interno), mesmo aqueles que são executados em outros nodes. Entre os plugins para criação de redes entre nodes, responsáveis por criar túneis seguros de comunicação, tem-se:</p>
            <ul>
                <li>Flannel;</li>
                <li>Weave.</li>
            </ul>

            <br><h4>Arquivo de Manifesto/Especificação</h4>
            <p id="textoPost">Podem ser escritos via yml ou json, como modelo abaixo:</p>
<small><pre><code>
<b>apiVersion:</b> v1
<span class="text-muted"># Comentário</span>
<b>kind:</b> Pod
<b>metadata:</b>
    <b>name:</b> kuard
<b>spec:</b>
    <b>containers:</b>
        <b>-image:</b> gcr.io/kuar-demo/kuard-amd64:blue
        <b>name:</b> kuard
        <b>ports:</b>
            <b>-containerPort:</b> 8080
            <b>name:</b> http
            <b>protocol:</b> TCP
</code></pre></small>

            <br><h4>Recursos/Objetos no K8s (Kind)</h4>
            <ul>
                <li>Pods;</li>
                <li>Nodes;</li>
                <li>Deployment;</li>
                <li>ReplicaSet;</li>
                <li>Service.</li>
            </ul>

            <br><h4>kubectl e maneiras de interação</h4>
            <p id="textoPost">Há 2 maneiras básicas de interagir com K8s:</p>
            <ul>
                <li><b>Imperativa</b>: Através de diversos parâmetros do kubectl;
                    <ul>
                        <li>Diz ao K8s o que fazer (Ex: 'Crie 3 Pods com configurações X');</li>
                        <li>Ideal para aprendizado, visando experimentos interativos ou debugar serviços em produção.</li>
                    </ul>
                </li>
                <li><b>Declarativa</b>: Escrevendo manifestos e os usando com o comando <i>kubectl apply</i>.
                    <ul>
                        <li>Diz ao K8s o que você quer (Ex: 'Quero que seja XYZ', então serão feitas, automaticamente, criações e gestão de Pods e afins para alcançar o objetivo solicitado);</li>
                        <li>Melhor para implantar serviços de maneira a facilitar reprodutibilidade;</li>
                        <li>Recomendado para gerenciar aplicações K8s em produção.</li>
                    </ul>
                </li>
            </ul>

            <br><h5>Comandos de Abordagem Imperativa:</h5>
            <p id="textoPost">Kubectl <i>get</i>, <i>describe</i> e <i>delete</i> podem ser usados com quaisquer recursos. Além desses, tem-se também <i>create</i>, <i>run</i>, <i>scale</i>, <i>expose</i>, <i>exec</i>, <i>copy</i> e <i>logs</i>.</p>
<small><pre><code>
<span class="text-muted"># Listar</span>
kubectl get pods
kubectl get nodes
kubectl get services

<span class="text-muted"># Ver informações detalhadas</span>
kubectl describe pod &lt;nome do Pod&gt;
kubectl describe service &lt;nome do Service&gt;

<span class="text-muted"># Exclusão</span>
kubectl delete pod &lt;nome do Pod&gt;
kubectl delete deployment &lt;nome do Deployment&gt;
</code></pre></small>

            <br><h5>Comandos de Abordagem Declarativa:</h5>
            <p id="textoPost">Em caso de mudanças no arquivo, <i>apply</i> atualiza os recursos.</p>
<small><pre><code>
kubectl apply -f &lt;arquivo.yaml&gt;
kubectl apply -f &lt;arquivo1.yaml&gt; -f &lt;arquivo2.yaml&gt;
kubectl apply -f &lt;folder&gt;/
</code></pre></small>

            <br><h4>Criar Pod</h4>
            <p id="textoPost">Há diversos maneiras, entre as principais, via comando '<i><span class="text-muted">kubectl run nginx --generator=run-pod/v1 --image=nginx</span></i>', ou via arquivo yml:</p>
<small><pre><code>
<span class="text-muted">cat &lt;&lt; EOF | kubectl create -f -</span>
apiVersion: <span class="text-muted">v1</span>
kind: <span class="text-muted">Pod</span>
metadata:
    name: <span class="text-muted">nginx-pod</span>
spec:
    containers:
        -name: <span class="text-muted">nginx-container</span>
        image: <span class="text-muted">nginx</span>
EOF
</code></pre></small>

            <br><h4>Exportar manifesto</h4>
            <ol>
                <li>Salvar manifesto de um Pod: <span class="text-muted">kubectl get pod my-pod -o yaml &gt; my-pod.yaml</span></li>
                <li>Salvar manifesto sem informações específicas do cluster: <span class="text-muted">kubectl get pod my-pod -o yaml --export &gt; my-pod.yaml</span></li>
            </ol>

            <br><h4>Namespace</h4>
            <p id="textoPost">K8s usa namespaces para organizar objetos no cluster através de uma divisão lógica (Como se fosse uma pasta). Por padrão, kubectl interage com o namespace padrão (default). Para usar namespace específico (Diferente do padrão), pode-se usar a flag <span class="text-muted">--namespace=&lt;nome&gt;</span>, ou ainda <span class="text-muted">-n &lt;nome&gt;</span>. Para interagir com todos os namespaces, pode-se usar a flag <span class="text-muted">--all-namespaces</span> ao comando.</p>
<small><pre><code>
<b>Criar namespace:</b>
kubectl create namespace dev
kubectl create namespace prod

<b>Listar namespaces:</b>
kubectl get namespaces

<b>Remover namespace:</b>
kubectl delete namespace dev

<b>Filtrar Pods por namespace:</b>
kubectl get pods --namespace=teste
kubectl get pods -n teste

<b>Listar Pods de todos namespaces:</b>
kubectl get pods --all-namespaces
</code></pre></small>

            <br><h4>Label</h4>
            <p id="textoPost">Par de chave-valor String. Todos os recursos/objetos do K8s podem ser rotulados. Ideal para filtragens/classificações. Existem 2 tipos de labels:</p>
<small><pre><code>
<b>1. Equality-based requirement (Igualdades/Diferenças):</b>
environment = production <span class="text-muted"># environment é igual a production</span>
tier != frontend

<b>2. Set-based requirement (Conjuntos):</b>
environment in (production, qa) <span class="text-muted"># environment está em production ou qa</span>
tier notin (frontend, backend)

<u>COMANDOS</u>:
<b>Mostrar labels dos recursos:</b>
kubectl get pods --show-labels

<b>Excluir Pods com label <i>run=myapp</i>:</b>
kubectl delete pods -l environment=production,tier=frontend
kubectl get pods -l 'environment in (production),tier in (frontend)'

<b>Atribuir label:</b>
kubectl label deployment nginx-deployment tier=dev
</code></pre></small>

            <br><h4>Instalação do K8s (Ubuntu)</h4>
            <p id="textoPost">Pode-se instalar a versão K8s Singlenode, via Microk8s (Para dispositivos embarcados, sendo mais estável) ou Minikube (Para ambientes Singlenode). Tem-se, também, a instalação em cluster (Instruções abaixo), onde precisa-se definir Master(s), Worker Nodes.</p>
<small><pre><code>
<b>1. Instalar Docker em todos Nodes:</b>
sudo apt install curl
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
sudo apt update && sudo sudo apt list docker-ce -a

sudo apt install docker-ce=18.06.1~ce~3-0~ubuntu
sudo apt-mark hold docker-ce
cat &gt; /etc/docker/daemon.json &lt;&lt;EOF
{
    "exec-opts": ["native.cgroupdriver=systemd"],
    "log-driver": "json-file"
    "log-opts": {
        "max-size": "100m"
    },
    "storage-driver": "overlay2"
}
EOF

mkdir -p /etc/systemd/system/docker.service.d
systemctl daemon-reload
systemctl restart docker
sudo docker version

<b>2. Instalar K8s em todos Nodes:</b>
<span class="text-muted"># No final, desabilita-se swap para que o K8s funcione melhor</span>
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
cat &lt;&lt; EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list
deb https://apt.kubernetes.io/ kubernetes-xenial main
EOF

sudo apt update
sudo apt list kubelet -a

sudo apt install kubelet=1.12.7-00 kubeadm=1.12.7-00 kubectl=1.12.7-00
sudo apt-mark hold kubelet kubeadm kubectl
sudo kubeadm version

sudo swapoff -a
sudo sed -i'/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
</code></pre></small>

            <!--VER AULA 6 - CONFIGURAÇÃO DO K8s-->
        </div>
    </div>


<!--Rodapé-->
<div class="row">
    <div class="col-sm-12 text-center" id="rodape">
        <p id="serifada">Elaborado por Mateus Schwede<br><small class="text-muted">ubsocial.github.io</small></p>
    </div>
</div>

</div>
</body>
</html>